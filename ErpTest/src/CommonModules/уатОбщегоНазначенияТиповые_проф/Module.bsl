// Функция вызывается из форм платежных документов при смене кассы или 
// банковского счета. Меняет валюту, курс документа. Возвращает сумму.
//
// Параметры:
//  ВалютаДокумента  - ссылка на справочник, валюта документа до изменения;
//  КурсДокумента    - число, курс документа до изменения; 
//  ДатаДокумента    - дата, дата на которую будем получать новый курс; 
//  СуммаДокумента   - число, сумма документа; 
//  ВалютаДенежныхСредств - ссылка на справочник, валюта выбранного счета или кассы 
//                     (новая валюта документа);
//
Функция ПриИзмененииЗначенияКассыБанковскогоСчета(ВалютаДокумента, КурсДокумента, КратностьДокумента, ДатаДокумента, 
											СуммаДокумента, ВалютаДенежныхСредств) Экспорт
	
	Результат = Новый Структура("флТребуетПересчета");
	
	// Поменяем валюту до вопроса о пересчете, чтобы было видно, что она действительно поменялась.
	СтараяВалюта    = ВалютаДокумента; 
	СтарыйКурс      = КурсДокумента;
	СтараяКратность = КратностьДокумента;
	ВалютаДокумента = ВалютаДенежныхСредств; // должны строго совпадать
	
	СтруктураКурсаВалютаДокумента = уатОбщегоНазначенияТиповыеСервер.ПолучитьКурсВалюты(ВалютаДокумента, ДатаДокумента);
	КурсДокумента      = СтруктураКурсаВалютаДокумента.Курс;
	КратностьДокумента = СтруктураКурсаВалютаДокумента.Кратность;
	
	Если Не ВалютаДокумента = СтараяВалюта И СуммаДокумента > 0 Тогда
		Возврат уатОбщегоНазначенияТиповыеСервер.ПересчитатьИзВалютыВВалюту(СуммаДокумента, СтараяВалюта, ВалютаДокумента, СтарыйКурс,
			КурсДокумента, СтараяКратность, КратностьДокумента);
	Иначе 
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПриИзмененииЗначенияКассыБанковскогоСчета()

// Функция дополняет текст часть сформированного запроса по определенным полям
//
// Параметры:
//  МассивПоказателей - Массив показателей для которых необходимо построить запрос
//  ПоляДляВыборки - поля для выборки
//  ИспользоватьАлиасыПолей - признак использования подсказок полей
//  ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя - признак использования в качестве префикса алиасов
//  ПолучатьРазвернутыйОстаток - признак получения развернутого сальдо
// Возвращаемое значение:
//  Строка - текст запроса
Функция ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомость(МассивПоказателей, Знач ПоляДляВыборки = Истина, 
		Знач ИспользоватьАлиасыПолей = Ложь, Знач ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя = Ложь, ПолучатьРазвернутыйОстаток = Ложь) Экспорт
		
	СтрокаЗапроса = "";	
	РазвернутыйОстаток = ?(ПолучатьРазвернутыйОстаток, "Развернутый", "");
			
	Если ПоляДляВыборки Тогда
		
		Если ИспользоватьАлиасыПолей Тогда
			// выборка с алиасами
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаПрефикса = ?(ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя, ИмяПоказателя, ""); 
							
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт КАК " + СтрокаПрефикса + "НачальныйОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт КАК " + СтрокаПрефикса + "НачальныйОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт КАК "                                     + СтрокаПрефикса + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт КАК "                                     + СтрокаПрефикса + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт КАК "  + СтрокаПрефикса + "КонечныйОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт КАК "  + СтрокаПрефикса + "КонечныйОстатокКт";
					
			КонецЦикла;
			
		Иначе	
			// выборка без алиасов
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт";
								
			КонецЦикла;
            	

		КонецЕсли;	
		
	Иначе
		// выборка для суммирования
		Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
						
			СтрокаЗапроса = СтрокаЗапроса + ",
			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт),
			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт),
			|	СУММА(" + ИмяПоказателя + "ОборотДт),
			|	СУММА(" + ИмяПоказателя + "ОборотКт),
			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт),
			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт)";

					
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтрокаЗапроса;
	
КонецФункции

// Функция формирует текст строки запроса для выборки данных оборотов и остатков регистра бухгалтерии
//
// Параметры:
//  СтруктураПараметров - структура параметров
//  ИмяАлиасаТаблицы - имя заголовка таблицы
//  ДопОграничениеПоСчету - дополнительные ограничения по счету
// 
// Возвращаемое значение:
//  Текст - текст запроса
//
Функция СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, 
	Знач ИмяАлиасаТаблицы = "ОстаткиИОбороты", Знач ДопОграничениеПоСчету = "" ) Экспорт
	
	СтрокаОграниченийПоРеквизитам = "";
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ОтражениеВНУ", СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Валюта", СтруктураПараметров.СтруктураОграничений.Валюта);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Сценарий", СтруктураПараметров.СтруктураОграничений.Сценарий);
		
	СтрокаСвязкиДопОграниченияПоСчету = ?(ПустаяСтрока(ДопОграничениеПоСчету), "", " И ");
	
	СтрокаЧастиЗапроса = "
			|ИЗ
			|	РегистрБухгалтерии." + СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии + ".ОстаткиИОбороты( "
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаНач = '00010101000000', "", "&НачПериода") + ", "
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаКон = '00010101000000', "", "&КонПериода") 
			+ ", , , " + ДопОграничениеПоСчету  
			+ ?(СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Ложь 
				ИЛИ СтруктураПараметров.СтруктураОграничений.ПоЗабалансовымСчетам = Истина, "", СтрокаСвязкиДопОграниченияПоСчету + " НЕ Счет.Забалансовый ") + ", "
			+ ", "
			+ СтрокаОграниченийПоРеквизитам + ") КАК " + ИмяАлиасаТаблицы;
			
	Возврат СтрокаЧастиЗапроса;		
	
КонецФункции

// Процедура формирует строку ограничений для выборки из таблицы оборотов и остатков регистров бухгалтерии
//
// Параметры:
//  СтрокаОграничения - строка ограничения
//  ИмяОграниченияПоРеквизиту - имя ограничения по реквизиту
//  ОграничениеПоРеквизиту - ограничение по реквизиту
//
Процедура ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграничения, Знач ИмяОграниченияПоРеквизиту, Знач ОграничениеПоРеквизиту) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ОграничениеПоРеквизиту) и не ТипЗнч(ОграничениеПоРеквизиту) = Тип("СправочникСсылка.уатСценарииПланирования") Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " = &" + ИмяОграниченияПоРеквизиту + " ";
	
	СтрокаОграничения = ОбъединитьОграничения(СтрокаОграничения, СтрокаНовогоОграничения);
    
КонецПроцедуры

//Функция Объединяет ограничения
Функция ОбъединитьОграничения(Знач Ограничение1, Знач Ограничение2, Знач СтрокаОбъединенияОграничений = "И")
	
	Если ПустаяСтрока(Ограничение1) Тогда
		Возврат Ограничение2;
	КонецЕсли;
	
	Если ПустаяСтрока(Ограничение2) Тогда
		Возврат Ограничение1;
	КонецЕсли;
	
	СтрокаОграничения = Ограничение1 + " " + СтрокаОбъединенияОграничений + " " + Ограничение2;
	
	Возврат СтрокаОграничения;
	
КонецФункции

// Формирует строку ограничений по датам отчета для показа в заголовке формы
//
// Параметры:
//	ДатаНач
//  ДатаКон
Функция СформироватьСтрокуВыводаПараметровПоДатам(Знач ДатаНач, Знач ДатаКон) Экспорт

	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда

		ОписаниеПериода     = "Период: без ограничения.";

	Иначе

		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда

			ОписаниеПериода = "Период: " + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""") 
							+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""");

		Иначе

			ОписаниеПериода = "Период: " + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");

		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции

// Процедура формирует отчет оборотно сальдовой ведомости
// 
// Параметры:
//  ОбъектОтчета - Объект отчета
//  ДокументРезультат - документ результат
//  ПоказыватьЗаголовок  - признак отображения заголовка
//  ВысотаЗаголовка - высота заголовка
//  ПоВалютам    - признак вывода отчета по валютам
//  ИспользоватьОграниченияПоЗабалансовымСчетам - признак использования ограничения
//  ПоЗабалансовымСчетам - признак вывода в отчет забалансовых счетов
//  ВидУчета     - вид учета
//  Валюта       - валюта
//  ОтражениеВНУ - отражение в налоговом учете
//  Сценарий     - сценарий планирования
//  ВВалютеСценария - признак вывода отчета в валюте сценария
//
Процедура СформироватьОтчетОборотноСальдовойВедомости(ОбъектОтчета, ДокументРезультат, ПоказыватьЗаголовок = Истина, ВысотаЗаголовка = 0,
	Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам, 
	Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено, 
	Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено) Экспорт
    	
	ОграничениеПоДатамКорректно = ПроверитьКорректностьОграниченийПоДатам(ОбъектОтчета.ДатаНач, ОбъектОтчета.ДатаКон);
	Если НЕ ОграничениеПоДатамКорректно Тогда
        Возврат;
	КонецЕсли;

	ДокументРезультат.Очистить();

	СформироватьИВывестиЗаголовокОтчета(ОбъектОтчета, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок);
	
	Макет = ПолучитьОбщийМакет("ОборотноСальдоваяВедомость");
		
	ЗаголовокОтчета = Макет.ПолучитьОбласть("ЗаголовокОтчета");
	
	ДокументРезультат.Вывести(ЗаголовокОтчета, 1);

	ДокументРезультат.НачатьАвтогруппировкуСтрок();

	// Используемые области макета
	ОбластьСтрокаСчет           = Макет.ПолучитьОбласть("Строка|Счет");
	ОбластьСтрокаПоказателяСчет = Макет.ПолучитьОбласть("СтрокаПоказателя|Счет");

	// В этой структуре будут храниться постоянные значения, передаваемые во другие процедуры:
	// - формат, 
	// - области макета
	СтруктураПараметров = Новый Структура;
	
	// Переменная, содержащая имена показателей отчета (ресурсов) в виде массива
	МассивПоказателей = ОбъектОтчета.СформироватьМассивПоказателей();
	СтруктураПараметров.Вставить("МассивПоказателей", МассивПоказателей);
	
	// Области для вывода показателей
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяЧисла",Макет.ПолучитьОбласть("СтрокаПоказателя|Числа"));
	СтруктураПараметров.Вставить("ОбластьСтрокаЧисла",          Макет.ПолучитьОбласть("Строка|Числа"));
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет", Макет.ПолучитьОбласть("СтрокаПоказателя|Счет"));

	// Линии, используемые при выводе
	СтруктураПараметров.Вставить("НетЛинии",    Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии, 1));

	// Формат показателей
	СтруктураФорматовПоказателей = СформироватьСтруктуруФорматовПоказателей(МассивПоказателей, ОбъектОтчета.ИмяРегистраБухгалтерии);
	СтруктураПараметров.Вставить("ФорматПоказателей", СтруктураФорматовПоказателей);
	
	СтруктураПараметровОграничений = СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
		ПоВалютам, ИспользоватьОграниченияПоЗабалансовымСчетам, ПоЗабалансовымСчетам, ВидУчета, Валюта, ОтражениеВНУ, 
		Сценарий, ВВалютеСценария);
		
	СтруктураПараметров.Вставить("СтруктураОграничений", СтруктураПараметровОграничений);
	
    СтруктураОбщийИтог = Новый Структура;
	ИнициализироватьСтруктуруХраненияИтоговОборотка(МассивПоказателей, СтруктураОбщийИтог);
		
	СоотвПодчСчета = Новый Соответствие;
	
	Запрос = ОбъектОтчета.СформироватьЗапрос(СтруктураПараметров);

	// Рассчитаем итоги по счетам, заданным в таблице вывода итогов по счетам
	ТаблицаРазворотаСчетов = СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, ОбъектОтчета.ПравилаВыводаИтогов);
	ТаблицаРазворотаСчетов.Индексы.Добавить("Счет");
		
	// Рассчитаем итоги по счетам, заданным в таблице развернутого сальдо
	ТаблицаРазвернутогоСальдо = СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ОбъектОтчета.ПравилаРазвернутогоСальдо); 
	ТаблицаРазвернутогоСальдо.Индексы.Добавить("Счет");

	РезультатЗапроса = Запрос.Выполнить();

	Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Счет");

	Пока Выборка.Следующий() Цикл
		
		Уровень = Выборка.Уровень();
		
		Если НЕ ОбъектОтчета.ПоСубсчетамИСубконто
			И Уровень > 0 Тогда
						
			Продолжить;
			
		КонецЕсли;
		
		// Пропускаем подчиненные счета разворачиваемого счета
		Если СоотвПодчСчета[Выборка.Счет] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		// Заполнение параметров расшифровки
		ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(ОбъектОтчета.ДатаНач, ОбъектОтчета.ДатаКон, 
			ОбъектОтчета.ИмяРегистраБухгалтерии, ОбластьСтрокаСчет, Выборка, , , ВВалютеСценария);
		
		// выводим текущую строку отчета
		ДокументРезультат.Вывести(ОбластьСтрокаСчет, Уровень);
		
		// Определим, нужно ли выводить развернутое сальдо по счету и
		// разворачивать счет по субконто
		Если ОбъектОтчета.ВыводитьРазвернутоеСальдо Тогда
			СтрокаРазвернутогоСальдо = ТаблицаРазвернутогоСальдо.Найти(Выборка.Счет, "Счет");
		Иначе	
			СтрокаРазвернутогоСальдо = Неопределено;
		КонецЕсли;
		
		Если ОбъектОтчета.ПоСубсчетамИСубконто Тогда
			СтрокаРазворотаСчета = ТаблицаРазворотаСчетов.Найти(Выборка.Счет, "Счет");
		Иначе
			СтрокаРазворотаСчета = Неопределено;
		КонецЕсли;
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Выборка.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);
		
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, ДокументРезультат, СтрокаРазвернутогоСальдо, 
			СтруктураОбщийИтог, -1);
						
		// Вывод разворота счета по субконто
		Если СтрокаРазворотаСчета <> Неопределено Тогда
			
			СтрокаРазвернутогоСальдо = Неопределено;
			СоотвПодчСчета = СтрокаРазворотаСчета.СоответсвиеСчетов;
			
			// Сдвиг уровня выводимой группировки отчета относительно группировки запроса
			СдвигУровня = 0;
			
			// Флаг сброса сдвига уровня при выводе группировки по счету
			СброситьСдвигУровня = Истина;
			
			ВыборкаПоСчету = СтрокаРазворотаСчета.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, СтрокаРазворотаСчета.МассивГруппировок[0]);
			
			СтруктураПараметров.Вставить("ОбластьСтрокаСчет",           ОбластьСтрокаСчет);
			СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет", ОбластьСтрокаПоказателяСчет);
			СтруктураПараметров.Вставить("ДокументРезультат", ДокументРезультат);
			
			//вывод детализированных данных
			ВывестиГруппировкуОборотноСальдовойВедомости(ВыборкаПоСчету, 0, СтрокаРазворотаСчета.МассивГруппировок, 
				Уровень, СдвигУровня, СброситьСдвигУровня, 
				Выборка.Счет, СтрокаРазвернутогоСальдо, 
				СтруктураОбщийИтог, СтруктураПараметров, Новый Соответствие);
			
		КонецЕсли;

	КонецЦикла;

	ДокументРезультат.ЗакончитьАвтогруппировкуСтрок();

	// Выведем итоговую строку
	ОбластьИтогиСчет = Макет.ПолучитьОбласть("Итоги|Счет");
	ДокументРезультат.Вывести(ОбластьИтогиСчет, 0);
	
	ОбластьИтогиСтрокаЧисла = Макет.ПолучитьОбласть("ИтогиСтрока|Числа");
	ОбластьИтогиЧисла       = Макет.ПолучитьОбласть("Итоги|Числа");
	ОбластьИтогиСтрокаСчет  = Макет.ПолучитьОбласть("ИтогиСтрока|Счет");
	
	НомерТекущейСтрокиИтога = 0;	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл

		Если НЕ Метаданные.РегистрыБухгалтерии[ОбъектОтчета.ИмяРегистраБухгалтерии].Ресурсы[ИмяПоказателя].Балансовый Тогда
			Продолжить;
		КонецЕсли;

		Если НомерТекущейСтрокиИтога > 0 Тогда
			Область = ОбластьИтогиСтрокаЧисла
		Иначе
			Область = ОбластьИтогиЧисла;
		КонецЕсли;

		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
			СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"], СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"], 
			СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"], СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"], 
			СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"], СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"]);
		
		Если НомерТекущейСтрокиИтога > 0 Тогда
			ДокументРезультат.Вывести(ОбластьИтогиСтрокаСчет, 0);
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		НомерТекущейСтрокиИтога = НомерТекущейСтрокиИтога + 1;

	КонецЦикла;

	ИтогиПодвал = Макет.ПолучитьОбласть("ИтогиПодвал");
   	ДокументРезультат.Вывести(ИтогиПодвал, 0);
	
		
	// Заполним общую расшифровку:
	СтруктураНастроекОтчета = ОбъектОтчета.СформироватьОбщуюСтруктуруДляРасшифровки();
    СтруктураНастроекОтчета.Вставить("ПоказыватьЗаголовок", ПоказыватьЗаголовок);

	ДокументРезультат.Область(1, 1).Расшифровка = СтруктураНастроекОтчета;

    // Зафиксируем заголовок отчета
	ДокументРезультат.ФиксацияСверху = ВысотаЗаголовка + 3;

	// Первую колонку не печатаем
	ДокументРезультат.ОбластьПечати = ДокументРезультат.Область(1, 2, ДокументРезультат.ВысотаТаблицы, ДокументРезультат.ШиринаТаблицы);
	
	// Выводится по ширине листа
	ДокументРезультат.Автомасштаб   = Истина;

КонецПроцедуры

//процедура формирует заголовок отчета
Процедура СформироватьИВывестиЗаголовокОтчета(ОтчетОбъект, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок)
	
	ОбластьЗаголовка = ОтчетОбъект.СформироватьЗаголовок();
	ВысотаЗаголовка = ОбластьЗаголовка.ВысотаТаблицы;
	ДокументРезультат.Вывести(ОбластьЗаголовка, 1);
	
	Если ЗначениеЗаполнено(ВысотаЗаголовка) Тогда
		ДокументРезультат.Область("R1:R" + ВысотаЗаголовка).Видимость = ПоказыватьЗаголовок;
	КонецЕсли;
	
КонецПроцедуры

//Функция возвращает корректные или нет ограничения по датам для отчета
// в случае если ограничения не корректны - выдается предупреждение
Функция ПроверитьКорректностьОграниченийПоДатам(Знач ДатаНач, Знач ДатаКон, Знач ВыдаватьПредупреждение = Истина)
	
	// Проверка на пустые значения
	Если ДатаНач > ДатаКон И ДатаКон <> '00010101000000' Тогда

		Если ВыдаватьПредупреждение Тогда 
			Сообщить("Дата начала периода не может быть больше даты конца периода");
		КонецЕсли;
	
		Возврат Ложь;

	КонецЕсли;
	
	Возврат Истина;

КонецФункции

//функция возвращает структуру форматов показателей по массиву показателей
Функция СформироватьСтруктуруФорматовПоказателей(Знач МассивПоказателей, Знач ИмяРегистраБухгалтерии)
	
	ФорматПоказателей = Новый Структура();
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		Ресурс = Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы.Найти(ИмяПоказателя);
		Если Ресурс <> Неопределено Тогда
			
			ФорматПоказателей.Вставить(ИмяПоказателя,"ЧЦ = " + Ресурс.Тип.КвалификаторыЧисла.Разрядность
			+ " ; ЧДЦ = " + Ресурс.Тип.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			
		Иначе // по умолчанию - сумма
			ФорматПоказателей.Вставить(ИмяПоказателя ,"ЧЦ = 15 ; ЧДЦ = 2");
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ФорматПоказателей;
	
КонецФункции

//Функция формирует структуру параметров ограничений для оборотно-сальдовой ведомости
Функция СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
		Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам = Ложь, 
		Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено,
		Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено)
	
	Структура = Новый Структура();
	Структура.Вставить("ДатаНач", ОбъектОтчета.ДатаНач);
	Структура.Вставить("ДатаКон", ОбъектОтчета.ДатаКон);
	Попытка
		Структура.Вставить("Организация", ОбъектОтчета.Организация);
	Исключение
		Структура.Вставить("Организация", Неопределено);
	КонецПопытки;
	
	Структура.Вставить("ПоСубсчетамИСубконто", ОбъектОтчета.ПоСубсчетамИСубконто);
	Структура.Вставить("ВыводитьРазвернутоеСальдо", ОбъектОтчета.ВыводитьРазвернутоеСальдо);
	
	Структура.Вставить("ПоВалютам", ПоВалютам);
	Структура.Вставить("ИспользоватьОграниченияПоЗабалансовымСчетам", ИспользоватьОграниченияПоЗабалансовымСчетам);
	Структура.Вставить("ПоЗабалансовымСчетам", ПоЗабалансовымСчетам);
	
	Структура.Вставить("ВидУчета", ВидУчета);	
	
	Структура.Вставить("Валюта",  Валюта);
	Структура.Вставить("ОтражениеВНУ",  ОтражениеВНУ);
	
	Структура.Вставить("Сценарий",  Сценарий);
	
	Структура.Вставить("ВВалютеСценария",  ВВалютеСценария);
	
	Структура.Вставить("ИмяРегистраБухгалтерии", ОбъектОтчета.ИмяРегистраБухгалтерии);
	
	Возврат Структура; 
	
КонецФункции

// процедура инициализирует структуру в которой хранятся итоговые суммы документа
Процедура ИнициализироватьСтруктуруХраненияИтоговОборотка(Знач МассивПоказателей, СтруктураОбщийИтог)
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотКт", 0);
						
	КонецЦикла;
	
КонецПроцедуры

// Формирует запросы по каждому счету, указанному в таблице вывода итогов
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Таблица запросов
//
Функция СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, Знач ПравилаВыводаИтогов)

	// Результат функции будут укладываться в таблицу
	ТаблицаРазворотаСчетов = Новый ТаблицаЗначений;
	ТаблицаРазворотаСчетов.Колонки.Добавить("Счет");
	ТаблицаРазворотаСчетов.Колонки.Добавить("Результат");
	ТаблицаРазворотаСчетов.Колонки.Добавить("МассивГруппировок");
	ТаблицаРазворотаСчетов.Колонки.Добавить("СоответсвиеСчетов");

	Если НЕ СтруктураПараметров.СтруктураОграничений.ПоСубсчетамИСубконто
		ИЛИ ПравилаВыводаИтогов.Количество() = 0 Тогда
		
		Возврат ТаблицаРазворотаСчетов;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода", НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода", КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Запрос.УстановитьПараметр("Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	Запрос.УстановитьПараметр("ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта",  СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ",  СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий",  СтруктураПараметров.СтруктураОграничений.Сценарий);
		
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаВыводаИтогов Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			ИЛИ (НЕ ПравилаСчета.Субсчета
				И ПравилаСчета.РазворотПоСубконто.Количество() = 0) Тогда
				
			Продолжить; // неправильно заполненная строка, не обрабатываем
				
		КонецЕсли;
		
		ТекстЗапроса = "";
		ТекстИтогов  = "";
		ТекстВыбранныеПоля = "";
		ТекстИтогиПо = "";
					
		МассивГруппировок = Новый Массив;
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);

		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Счет КАК Счет";
			
		ТекстВнеш = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет,
		|	Счет.Код КАК СчетКод,
		|	Счет.Наименование КАК СчетНаименование,
		|	Счет.Представление КАК СчетПредставление,
		|	Счет.Забалансовый КАК СчетЗабалансовый";

		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта";
				
			ТекстВнеш = ТекстВнеш + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
		
		МассивГруппировок.Добавить("Счет");
		Если ПравилаСчета.Субсчета Тогда
			
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ИЕРАРХИЯ";
						
		Иначе
				
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ";
							
		КонецЕсли;
		
		// признак того, что можно использовать вложенный запрос 
		МожноИспользоватьСоставнойЗапрос = ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета);
						
		Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
			
			ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
			
			Если ВидСубконто = Неопределено Тогда
				Продолжить;
			КонецЕсли;
				
			Сч = ВидСубконто.НомерСтроки;
				
			// Определим тип значения поля и в соответствии с этим типом добавим поле запроса
			ТипыСубконто = ВидСубконто.ВидСубконто.ТипЗначения;
			Выб = "";
			ВыбИначе = "";
			
			ЕстьПредставление = Истина;
			Для Каждого Элемент Из ТипыСубконто.Типы() Цикл
				
				ОбъектМетаданных = Метаданные.НайтиПоТипу(Элемент);
				
				Если ОбъектМетаданных <> Неопределено Тогда
					
					ИмяТаблицы = ОбъектМетаданных.ПолноеИмя();
					Выб = Выб + "КОГДА #Поле ССЫЛКА " + ИмяТаблицы + " ТОГДА ВЫРАЗИТЬ( #Поле КАК (" + ИмяТаблицы + "))";
						
					Если Метаданные.Перечисления.Найти(ОбъектМетаданных.Имя) <> Неопределено Тогда
						ЕстьПредставление = Ложь;
					КонецЕсли;
					
				Иначе
					// Для примитивных типов придется добавлять само значение
					ВыбИначе = " #Поле ";
					ЕстьПредставление = Ложь;
					
				КонецЕсли;
					
			КонецЦикла;
			
			// окончательное формирование строки выбора поля
			Если НЕ ПустаяСтрока(Выб) Тогда
				
				Если НЕ ПустаяСтрока(ВыбИначе) Тогда
					СтрПоле = "
					|	ВЫБОР " + Выб + " ИНАЧЕ " + ВыбИначе + " КОНЕЦ";
				Иначе
					СтрПоле = "
					|	ВЫБОР " + Выб + " КОНЕЦ";
				КонецЕсли;
				
			Иначе
				
				СтрПоле = ВыбИначе;
				
			КонецЕсли;
				
			ТекстВыбранныеПоля = ТекстВыбранныеПоля + ", " + СтрЗаменить(СтрПоле, "#Поле", " ОстаткиИОбороты.Субконто"  + Сч) + " КАК Субконто" + Сч;
			
			СтрокаТипИзмерения = ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса("Элементы");
			ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя + СтрокаТипИзмерения;
			
			// само поле
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			// поле представления
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			
			Если ЕстьПредставление 
				И МожноИспользоватьСоставнойЗапрос Тогда
				
				ТекстВнеш  = ТекстВнеш + ".Представление ";
				
			КонецЕсли;
			
			ТекстВнеш  = ТекстВнеш + " КАК " + СтрокаПоСубконто.Имя + "Представление";
				
			МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
				
		КонецЦикла; 

		ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;

			
		// Добавим в текст запроса все выбранные ресурсы 
			
		ТекстЗапроса = ТекстЗапроса + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина, 
				Истина, Истина);
			
		ТекстВнеш = ТекстВнеш + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина);
			
		ТекстИтогов = ТекстИтогов + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Ложь);
						
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, ,
			"Счет В ИЕРАРХИИ (&Счет)");
		
		Если МожноИспользоватьСоставнойЗапрос Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
							
			ТекстЗапроса = ТекстВнеш + " ИЗ (" + ТекстЗапроса + " ) КАК Подзапрос 
			|	АВТОУПОРЯДОЧИВАНИЕ";
			
		Иначе
				
			ТекстЗапроса = ТекстВнеш + СтрокаТекстаВыборкиИзТаблицы + "
			|	АВТОУПОРЯДОЧИВАНИЕ";;
				
		КонецЕсли;

		Если Не ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ ";

			ТекстЗапроса = ТекстЗапроса + Сред(ТекстИтогов, 2);

			ТекстЗапроса = ТекстЗапроса + "
			|ПО " + Сред(ТекстИтогиПо, 2);

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
				
			КонецЕсли;

		КонецЕсли;
			
		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазворотаСчетов.Добавить();
		НоваяСтрока.Счет      = ПравилаСчета.Счет;
		НоваяСтрока.Результат = Запрос.Выполнить(); // в таблицу помещается выполненный запрос
		НоваяСтрока.МассивГруппировок = МассивГруппировок;
		
		ИмяПланаСчетов = Метаданные.РегистрыБухгалтерии[СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии].ПланСчетов.Имя;
		
		СооответствиеСчетов = ВернутьСоответвиеПодчиненныхСчетов(ИмяПланаСчетов, ПравилаСчета.Счет);
		НоваяСтрока.СоответсвиеСчетов = СооответствиеСчетов;
							
	КонецЦикла;

	Возврат ТаблицаРазворотаСчетов;
	
КонецФункции

// Формирует запросы по каждому из счетов, указанному в таблице развернутого сальдо
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Таблица запросов
//
Функция СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ПравилаРазвернутогоСальдо)

	// Результат Каждого запроса будет укладываться в специальную таблицу
	ТаблицаРазвернутогоСальдо = Новый ТаблицаЗначений;
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Счет");
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Результат");
	
	Если НЕ СтруктураПараметров.СтруктураОграничений.ВыводитьРазвернутоеСальдо
		ИЛИ (ПравилаРазвернутогоСальдо.Количество() = 0) Тогда
		
		Возврат ТаблицаРазвернутогоСальдо;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода", НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода", КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Запрос.УстановитьПараметр("Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	Запрос.УстановитьПараметр("ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта",  СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ",  СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий",  СтруктураПараметров.СтруктураОграничений.Сценарий);
	
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаРазвернутогоСальдо Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			ИЛИ (НЕ ПравилаСчета.Субсчета
				И ПравилаСчета.РазворотПоСубконто.Количество() = 0) Тогда
				
			Продолжить; // неправильно заполненная строка, не обрабатываем
				
		КонецЕсли;
		
		ТекстЗапроса = "";
		ТекстИтогов  = "";
		ТекстВыбранныеПоля = "";
			
		ТекстИтогиПо = "";
			
		МассивГруппировок = Новый Массив;
							
		МассивГруппировок.Добавить("Общие"); // всегда есть общий итог
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);
			
		ТекстЗапроса =  
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет ";
			
		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
			
		// Развернутое сальдо может быть подсчитано либо по субсчетам, либо по субконто
		Если ПравилаСчета.Субсчета Тогда
				
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ТОЛЬКО ИЕРАРХИЯ";
				
			МассивГруппировок.Добавить("Счет");
		Иначе
				
			Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
					
				ТекстВыбранныеПоля = ТекстВыбранныеПоля + ",
				|	" + СтрокаПоСубконто.Имя + " КАК " + СтрокаПоСубконто.Имя;
					
				ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя;
					
				МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
					
			КонецЦикла; 
				
			ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;
				
		КонецЕсли;

		// Добавим в текст запроса все выбранные ресурсы 
		Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл
				
			ТекстЗапроса = ТекстЗапроса + ",
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт";
				
			ТекстИтогов = ТекстИтогов + ",
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт)";
				
		КонецЦикла;
			
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, ,
			"Счет В ИЕРАРХИИ (&Счет)");
			
		ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
 			

		Если Не ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ ";

			ТекстЗапроса = ТекстЗапроса + Сред(ТекстИтогов, 2);

			ТекстЗапроса = ТекстЗапроса + "
			|ПО ОБЩИЕ " + ТекстИтогиПо;

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
			КонецЕсли;

		КонецЕсли;

		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазвернутогоСальдо.Добавить();
		НоваяСтрока.Счет      = ПравилаСчета.Счет;
		НоваяСтрока.Результат = Запрос.Выполнить(); // в таблицу помещается выполненный запрос
			
	КонецЦикла;

	Возврат ТаблицаРазвернутогоСальдо;

КонецФункции

// процедура Выводит данные по валютам
Процедура ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, 
	ДокументРезультат, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, Знач Отступ)
	
	// Если по валютам,
	Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда

		ВыборкаПоВалютам = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Валюта");
			
		Пока ВыборкаПоВалютам.Следующий() Цикл

			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);
			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "Валюта " + ВыборкаПоВалютам["ВалютаПредставление"];

			// Заполнение параметров расшифровки
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаПоказателяСчет, Выборка, , , СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);

			ОбластьСтрокаПоказателяСчет.Область(1, 4).Отступ = Отступ + 1;

			ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет, Выборка.Уровень());
				
			ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, ВыборкаПоВалютам, ВыборкаПоВалютам.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);

		КонецЦикла;
			
	КонецЕсли;
	
КонецПроцедуры


//функция возвращает соотвествие подчиненных счетов
Функция ВернутьСоответвиеПодчиненныхСчетов(Знач ИмяПланаСчетов = "", Знач Счет, Знач ДобавлятьСамСчетВСоответсвие = Ложь)
	
	СоответсвиеСчетов = Новый Соответствие;
	
	Запрос = Новый Запрос();
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ	ПланСчетов." + ИмяПланаСчетов + " КАК ПланСчетовРегистра
		|ГДЕ	ПланСчетовРегистра.Ссылка В Иерархии(&Ссылка)";
		
	Запрос.УстановитьПараметр("Ссылка", Счет);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если (НЕ ДобавлятьСамСчетВСоответсвие)
			И (Выборка.Ссылка = Счет) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		СоответсвиеСчетов.Вставить(Выборка.Ссылка, Выборка.Ссылка);
		
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции

//Функция возвращает часть запроса для иерархического вывода результатов отчета
Функция ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса(Знач ТипИзмерения) Экспорт
	
	Если ТипИзмерения = ТипИзмеренияПостроителяОтчета.Иерархия Тогда
		Возврат " ИЕРАРХИЯ";
	ИначеЕсли ТипИзмерения = ТипИзмеренияПостроителяОтчета.ТолькоИерархия Тогда	
		Возврат " ТОЛЬКО ИЕРАРХИЯ";
	Иначе	
		Возврат "";
	КонецЕсли;
	
КонецФункции

//Функция возвращает видсубконто по имени
Функция ВернутьСубконтоПоИмени(Знач Счет, Знач ИмяСубконто)
	
	// Найдем соответствующий вид субконто
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл
			
		Если "Субконто" + ВидСубконто.НомерСтроки = ИмяСубконто Тогда
				
			Возврат ВидСубконто;
				
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Заполняет параметры расшифровки переданной области перед выводом в отчет
//
// Параметры:
//	Область - табличный документ, параметры расшифровки которого заполняются,
//	Выборка - спозиционированная выборка из результата запроса,
//	ОтборСубконто - параметр, содержащий таблицу отбора, которая будет использована
//	при построении отчета по расшифровке.
//
Процедура ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(Знач ДатаНач, Знач ДатаКон, Знач ИмяРегистраБухгалтерии,
	Область, Выборка, ОтборСубконто = Неопределено, ВыведенныйСчет = Неопределено, Знач ВВалютеСценария = Неопределено)
	
	// Заполение значений для расшифровки
	СчетДляРасшифровки = ?(Выборка.Счет <> NULL, Выборка.Счет, ВыведенныйСчет);
	
	// Заполнение параметров расшифровки
	ПараметрыОСВПоСчету = Новый Соответствие;
	ПараметрыОСВПоСчету.Вставить("ИмяОбъекта", "ОборотноСальдоваяВедомостьПоСчету" + ИмяРегистраБухгалтерии);
	ПараметрыОСВПоСчету.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыОСВПоСчету.Вставить("Счет", СчетДляРасшифровки);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОСВПоСчету.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;

	ПараметрыКарточкиСчета = Новый Соответствие;
	ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", "КарточкаСчета" + ИмяРегистраБухгалтерии);
	ПараметрыКарточкиСчета.Вставить("Счет", СчетДляРасшифровки);
	
	ПараметрыАнализСчета = Новый Соответствие;
	ПараметрыАнализСчета.Вставить("ИмяОбъекта", "АнализСчета" + ИмяРегистраБухгалтерии);
	ПараметрыАнализСчета.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыАнализСчета.Вставить("Счет", СчетДляРасшифровки);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыАнализСчета.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;
	
	ПараметрыОборотыСчетаМесяц = Новый Соответствие;
	ПараметрыОборотыСчетаМесяц.Вставить("ИмяОбъекта", "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаМесяц.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыОборотыСчетаМесяц.Вставить("Счет", СчетДляРасшифровки);
	ПараметрыОборотыСчетаМесяц.Вставить("Период", "МЕСЯЦ");
	ПараметрыОборотыСчетаМесяц.Вставить("ВсеПериоды",  Истина);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОборотыСчетаМесяц.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;
	
	ПараметрыОборотыСчетаДень = Новый Соответствие;
	ПараметрыОборотыСчетаДень.Вставить("ИмяОбъекта", "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаДень.Вставить("ЗаполнитьПоУмолчанию", Истина);
    ПараметрыОборотыСчетаДень.Вставить("Счет", СчетДляРасшифровки);	
	ПараметрыОборотыСчетаДень.Вставить("Период",  "ДЕНЬ");
	ПараметрыОборотыСчетаДень.Вставить("ВсеПериоды",  Ложь);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОборотыСчетаДень.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;

	СписокРасшифровки = Новый СписокЗначений;
	ИмяГруппировки = Выборка.Группировка(); 
	
	Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" Тогда

		Если ОтборСубконто <> Неопределено Тогда
			
			ОтборСубконто.Вставить(ИмяГруппировки, Выборка[ИмяГруппировки]);
			
			// Область должна содержать свою копию отбора по субконто
			ОтборРасшифровка = СоздатьКопиюСоответствияСтруктуры(ОтборСубконто);
			
			ПараметрыКарточкиСчета.Вставить("Отбор", ОтборРасшифровка);
			
		КонецЕсли;

		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + Выборка.СчетПредставление);
		
	ИначеЕсли ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки.Добавить(ПараметрыОСВПоСчету,    "ОСВ по счету " + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыАнализСчета,   "Анализ счета " + Выборка.СчетПредставление);
		
		Если НЕ (Месяц(ДатаНач) = Месяц(ДатаКон) И Год(ДатаНач) = Год(ДатаКон))
			ИЛИ (ДатаНач = '00010101' И ДатаКон = '00010101') Тогда
			
			СписокРасшифровки.Добавить(ПараметрыОборотыСчетаМесяц,  "Обороты счета " + Выборка.СчетПредставление + " по месяцам");
			
		КонецЕсли;
		
		СписокРасшифровки.Добавить(ПараметрыОборотыСчетаДень,  "Обороты счета " + Выборка.СчетПредставление + " по дням");
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;

	Область.Параметры.Расшифровка = СписокРасшифровки;
	
КонецПроцедуры


// Выводит показатели
//
// Параметры:
//	ДокументРезультат - таблица отчета
//	Макет - используемый макет
//	Результат - выборка
//	Счет - счет выборки
//	ЭтоПерваяСтрока - признак вывода отступов перед субконто
//	СтрокаРазвернутогоСальдо - строка с выборкой - развернутым сальдо по счету
//	СтруктураОбщийИтог - структура, в которой накапливается общий итог.
//
Процедура ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров)

	ВыведеноПоказателей = 0;	
	
	ИмяГруппировки = Выборка.Группировка();
	
	Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл

		// Сумму в валюте выводим только по группировке Валюта
		Если ИмяПоказателя = "ВалютнаяСумма" И ИмяГруппировки <> "Валюта" Тогда
			Продолжить;			
		КонецЕсли;
		
		Если ИмяПоказателя = "НДС" И Счет.НДС = Ложь Тогда
			Продолжить;
		КонецЕсли;

		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		ВыведеноПоказателей = ВыведеноПоказателей + 1;
		
		Если ВыведеноПоказателей > 1 Тогда
			// без подчеркивания вверху
			Область = СтруктураПараметров.ОбластьСтрокаПоказателяЧисла;
		Иначе
			// есть подчеркивание вверху
			Область = СтруктураПараметров.ОбластьСтрокаЧисла;
		КонецЕсли;

		ОборотДт = Выборка[ИмяПоказателя + "ОборотДт"];
		ОборотКт = Выборка[ИмяПоказателя + "ОборотКт"];

		Если СтрокаРазвернутогоСальдо = Неопределено Тогда

			НачальныйОстатокДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
			НачальныйОстатокКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
			КонечныйОстатокДт  = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
			КонечныйОстатокКт  = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];

		Иначе

			// Спозиционируемся на самом верхнем итоге
			ВыборкаОбщиеИтоги = СтрокаРазвернутогоСальдо.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Если ВыборкаОбщиеИтоги.Следующий() Тогда
				НачальныйОстатокДт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокДт"];
				НачальныйОстатокКт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокКт"];
				КонечныйОстатокДт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокДт"];
				КонечныйОстатокКт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокКт"];
			Иначе
				НачальныйОстатокДт = 0;
				НачальныйОстатокКт = 0;
				КонечныйОстатокДт  = 0;
				КонечныйОстатокКт  = 0;
			КонецЕсли;

		КонецЕсли;

		// Накопление итогов по счетам
		НужноДополнятьИтоги = (ИмяГруппировки = "Счет") И (Выборка.Уровень() = 0);
		Если СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Истина Тогда 			
			
			НужноДополнятьИтоги = НужноДополнятьИтоги И	НЕ Выборка.СчетЗабалансовый;
			
		КонецЕсли;
			
		Если НужноДополнятьИтоги Тогда

			ДополнитьСтруктуруХраненияИтоговОборотка(ИмяПоказателя, СтруктураОбщийИтог,
				НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт, КонечныйОстатокКт,
				ОборотДт, ОборотКт);
				
		КонецЕсли;

		// заполняет данными область вывода
		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
			НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт,
			КонечныйОстатокКт, ОборотДт, ОборотКт);
			
		Если ВыведеноПоказателей > 1 Тогда

			ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			Если ИмяПоказателя = "ВалютнаяСумма" Тогда
				ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "Валютная сумма";
			Иначе
				ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "";
			КонецЕсли;
				
            ВыведеннаяОбласть = ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет);
			
			ВыведеннаяОбласть.ГраницаСверху = СтруктураПараметров.НетЛинии;
			
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
				
	КонецЦикла;

КонецПроцедуры

// процедура выводит текущие данные оборотки в область вывода
Процедура ЗаполнитьДаннымОблатьВыводаОборотка(Область, Знач ФорматПоказателя, 
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, 
	Знач КонечныйОстатокДт, Знач КонечныйОстатокКт, 
	Знач ОборотДт, Знач ОборотКт)
	
	Область.Параметры.НачальныйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
	Область.Параметры.НачальныйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
	Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйОстатокДт,  ФорматПоказателя);
	Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйОстатокКт,  ФорматПоказателя);
	Область.Параметры.ОборотДт           = Формат(ОборотДт,           ФорматПоказателя);
	Область.Параметры.ОборотКт           = Формат(ОборотКт,           ФорматПоказателя);
	
КонецПроцедуры


// процедура добавляет в итоговое хранилище сумм текущие данных
Процедура ДополнитьСтруктуруХраненияИтоговОборотка(Знач ИмяПоказателя, СтруктураОбщийИтог,
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, Знач КонечныйОстатокДт, Знач КонечныйОстатокКт,
	Знач ОборотДт, Знач ОборотКт)
	
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] = СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] + НачальныйОстатокДт;
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] = СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] + НачальныйОстатокКт;
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"] =  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт" ] + КонечныйОстатокДт;
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"] =  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт" ] + КонечныйОстатокКт;
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"] =           СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"]           + ОборотДт;
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"] =           СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"]           + ОборотКт;
	
КонецПроцедуры

// Создание копии структуры или соответствия
//
// Параментры:
//   СоотвИсх - Структура/Соответствие - Исходная структура, с которой будет создаваться копия.
//
// Возвращаемое значение:
//   Структура/Соответствие - Копия исходной структуры. Тип данных повторяет тип исходной структуры.
Функция СоздатьКопиюСоответствияСтруктуры(Знач СоответствиеИсточник) Экспорт
	
	Если СоответствиеИсточник = Неопределено Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	КопияСоответствия = Новый (ТипЗнч(СоответствиеИсточник));
		
	Для Каждого ЭлементОтбора Из СоответствиеИсточник Цикл
				
		КопияСоответствия.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
				
	КонецЦикла;
	
	Возврат КопияСоответствия;
	
КонецФункции

// Выводит группировку при развороте счета по субсчетам и/или субконто
//
// Параметры:
//	Выборка         - выборка из результата запроса по выводимой группировке,
//	ИндексТекущейГруппировки - индекс выводимой группировки в массиве группировок,
//	МассивГруппировок - массив, содержащий имена группировок, по которым строится разворот счета,
//	Уровень 		- уровень  группировки верхнего уровня
//	СдвигУровня     - сдвиг уровня группировки отчета относительно уровня группировки запроса,
//	СброситьСдвигУровня - признак сброса сдвига уровня,
//	СтрокаРазвернутогоСальдо - строка таблицы значений с развернутым сальдо по текущему счету.
//	СтруктураОбщийИтог - структура, в которой накапливаются общие итоги,
//	ПоследнийВыведенныйСчет - последний выведенный счет,
//	СтруктураПараметров - структура, содержащая неизменные для разворота счета параметры:
//	                      Области макета табличного документа, линии, уровень группировки, 
//	                      с которой начался вывод отчета.
//
Процедура ВывестиГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, 
	ОтборСубконто)

	Пока Выборка.Следующий() Цикл

		ИмяГруппировки = Выборка.Группировка();
		
		// Итоги более высокого уровня по счету - пропускаем (он уже выведен)
		Если ИмяГруппировки = "Счет" Тогда

			// При выводе субсчетов не делаем отступы
			Если СброситьСдвигУровня Тогда
				
				СброситьСдвигУровня = Ложь;
				СдвигУровня = 0;
				
			КонецЕсли;
			
			Отступ = 0;
			СдвигУровня = СдвигУровня + 1;

			// Уже выведенные счета не выводим
			Если ПоследнийВыведенныйСчет = Выборка.Счет 
				ИЛИ ПоследнийВыведенныйСчет.ПринадлежитЭлементу(Выборка.Счет) Тогда
				
				ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
					СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто);
					
				Продолжить;
				
			КонецЕсли;
			
		Иначе
			
			Отступ = Макс(Выборка.Уровень() - СдвигУровня, 0);
			СброситьСдвигУровня = Истина;
			
		КонецЕсли;
		
		ОбластьСтрокаСчет = СтруктураПараметров.ОбластьСтрокаСчет;
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		ВыводимаяОбласть = ОбластьСтрокаСчет;

		// Заполнение параметров расшифровки
		Если ИмяГруппировки = "Счет" Тогда
			
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаСчет, Выборка, , , СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);
				
		КонецЕсли;

		Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" тогда

			// Субконто, которых нет, равны NULL
			Если Выборка[ИмяГруппировки] = NULL Тогда
				Продолжить;
			КонецЕсли;

			ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;

			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);

			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки + "Представление"];
			
			ВыводимаяОбласть = ОбластьСтрокаПоказателяСчет;

			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ВыводимаяОбласть, Выборка, ОтборСубконто, ПоследнийВыведенныйСчет, СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);

			ВыводимаяОбласть.Область(1, 4).Отступ = Отступ;
			
			Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Истина);
			Иначе
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Ложь);
			КонецЕсли;

		КонецЕсли;

		ДокументРезультат = СтруктураПараметров.ДокументРезультат;
		ДокументРезультат.Вывести(ВыводимаяОбласть, Уровень + Выборка.Уровень());
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Выборка.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);

		// вывод данных по валютам
		ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, ДокументРезультат, 
			СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, Отступ);
		
		ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
			СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто);
											
	КонецЦикла;

КонецПроцедуры

//Функция возвращает можно ил использовать составной запрос для детализации по субконто
Функция ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета)
	
	// Определим признак использования составного запроса
	Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
		
		ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
		
		Если (ВидСубконто <> Неопределено)
			 И (ВидСубконто.ВидСубконто.ТипЗначения.Типы().Количество() > 10) Тогда
			 
			Возврат Ложь;
			
		КонецЕсли;
								
	КонецЦикла;

	Возврат Истина;
	
КонецФункции

//процедура выводит вложенную группировку
Процедура ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто)
	
	Если ИндексТекущейГруппировки + 1 >= МассивГруппировок.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ВывестиГруппировкуОборотноСальдовойВедомости(Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, МассивГруппировок[ИндексТекущейГруппировки + 1]), 
						ИндексТекущейГруппировки + 1, МассивГруппировок, Уровень, 
						СдвигУровня, СброситьСдвигУровня, ПоследнийВыведенныйСчет, 
						СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, СоздатьКопиюСоответствияСтруктуры(ОтборСубконто));
		
КонецПроцедуры	


// Процедура содает колонки у таблиц правила вывода итогов и правила развернутого сальдо
//
// Параметры:
//  ПравилаВыводаИтогов - Правила вывода итогов
//  ПравилаРазвернутогоСальдо - Правила развернутого сальдо 
//	ИмяРегистраБухгалтерии - Имя регистра бухгалтерии
//
Процедура СоздатьКолонкиУПравилВыводаИтоговИПравилаРазвернутогоСальдо(ПравилаВыводаИтогов, ПравилаРазвернутогоСальдо, 
	Знач ИмяРегистраБухгалтерии) Экспорт
	
	ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(200));

	МассивБулево        = Новый Массив;
	ОписаниеТиповБулево = Новый ОписаниеТипов("Булево");
    
	МассивТаблицаЗначений        = Новый Массив;
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов("ТаблицаЗначений");

	МассивСчет = Новый Массив;
	МассивСчет.Добавить(ТипЗнч(ПланыСчетов[Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].ПланСчетов.Имя].ПустаяСсылка()));
	ОписаниеТиповСчет  = Новый ОписаниеТипов(МассивСчет);

	// Создание структуры реквизитов - таблиц
	Если ПравилаВыводаИтогов <> Неопределено Тогда

		ПравилаВыводаИтогов.Колонки.Очистить();
		ПравилаВыводаИтогов.Колонки.Добавить("Счет",     ОписаниеТиповСчет);
		ПравилаВыводаИтогов.Колонки.Добавить("Субсчета", ОписаниеТиповБулево);
		ПравилаВыводаИтогов.Колонки.Добавить("ПредставлениеРазворотПоСубконто", ОписаниеТиповСтрока);
		ПравилаВыводаИтогов.Колонки.Добавить("РазворотПоСубконто", ОписаниеТиповТаблицаЗначений);
		
	КонецЕсли;

	Если ПравилаРазвернутогоСальдо <> Неопределено Тогда 
		
		ПравилаРазвернутогоСальдо.Колонки.Очистить();
		ПравилаРазвернутогоСальдо.Колонки.Добавить("Счет",     ОписаниеТиповСчет);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("Субсчета", ОписаниеТиповБулево);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("ПредставлениеРазворотПоСубконто", ОписаниеТиповСтрока);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("РазворотПоСубконто", ОписаниеТиповТаблицаЗначений);
		
	КонецЕсли;
    	
КонецПроцедуры

// Управляет пометками кнопок ком. панели
//
// Параметры:
//	ФормаОтчета
//  ПоказыватьЗаголовок - булево. Отображать пометку или нет
Процедура УправлениеПометкамиКнопокЗаголовковКоманднойПанели(ФормаОтчета, Знач ПоказыватьЗаголовок) Экспорт
	
	ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Заголовок.Пометка = ПоказыватьЗаголовок;
	ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Подменю.Кнопки.Заголовок.Пометка = ПоказыватьЗаголовок;
    	
КонецПроцедуры


// процедура заполняет таблицу настроек свойств
Процедура ЗаполнитьТаблицуНастроекСвойств(ЭтотОбъект, Знач ИмяРеквизита, Структура) Экспорт
	
	Источник = Неопределено;
	Если Структура.Свойство(ИмяРеквизита, Источник) <> Истина Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Приемник = ЭтотОбъект[ИмяРеквизита];
	Исключение
    	Возврат;
	КонецПопытки;
	
	Приемник.Очистить();
		
	// Загрузим совпадающие колонки.
	Для Каждого СтрокаТаблицыИсточника Из Источник Цикл
			
		СтрокаТаблицыПриемника = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника); 
			
	КонецЦикла;
		
КонецПроцедуры

// Процедура обрабатывает выпод заголовка
// 
// Параметры:
//
//
//
Процедура ОбработатьВыводЗаголовка(Форма, ОтчетОбъект, ВысотаЗаголовка, ПоказыватьЗаголовок) Экспорт

	// Перезаполнять заголовок можно только у "чистого" отчета
	Если Форма.ЭлементыФормы.ДокументРезультат.ВысотаТаблицы = 0 Тогда

		ОбластьЗаголовка = ОтчетОбъект.СформироватьЗаголовок();
		ВысотаЗаголовка = ОбластьЗаголовка.ВысотаТаблицы;
		Форма.ЭлементыФормы.ДокументРезультат.Вывести(ОбластьЗаголовка);
		
	КонецЕсли;

    Если ЗначениеЗаполнено(ВысотаЗаголовка) Тогда
		Форма.ЭлементыФормы.ДокументРезультат.Область("R1:R" + ВысотаЗаголовка).Видимость = ПоказыватьЗаголовок;
	КонецЕсли;

	УправлениеПометкамиКнопокЗаголовковКоманднойПанели(Форма, ПоказыватьЗаголовок);
	
КонецПроцедуры

// Формирует строку ограничений по датам отчета для показа в заголовке формы
//
// Параметры:
//	ДатаНач
//  ДатаКон
//
// Возвращаемое значение:
//  Строка ограничения
Функция СформироватьСтрокуОграниченийПоДатамДляФормы(Знач ДатаНач, Знач ДатаКон) Экспорт

	// Вывод заголовка, описателя периода и фильтров и заголовка
	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда

		ОписаниеПериода     = "Период не установлен";

	Иначе

		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда

			ОписаниеПериода = "" + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""...""") 
							+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""...""");

		Иначе

			Если ДатаНач <= ДатаКон Тогда
				ОписаниеПериода = "" + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");
			Иначе
				ОписаниеПериода = "Неправильно задан период!"
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции

// Обработка редактирования субконто
// 
// Параметры:
//  Элемент       - Элемент
//  ТекущиеДанныеТаблицыРедактирования - текущие данные
Процедура ОбработкаРедактированиеСубконто(Элемент, ТекущиеДанныеТаблицыРедактирования) Экспорт
	
	Если ТекущиеДанныеТаблицыРедактирования = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Счет = ТекущиеДанныеТаблицыРедактирования.Счет;
	Если НЕ ЗначениеЗаполнено(Счет) Тогда
		Сообщить("Не выбран счет!");
		Возврат;
	КонецЕсли;
	
	СписокСубконто = Новый СписокЗначений;
	
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл

		СписокСубконто.Добавить("Субконто" + Строка(ВидСубконто.НомерСтроки), Строка(ВидСубконто.ВидСубконто));
		
	КонецЦикла;

	// Данные этой строки должны быть отмечены
	Для Каждого Строка Из ТекущиеДанныеТаблицыРедактирования.РазворотПоСубконто Цикл
		
		ЭлементСписка = СписокСубконто.НайтиПоЗначению(Строка.Имя);
		Если ЭлементСписка <> Неопределено Тогда
			ЭлементСписка.Пометка = Истина;
		КонецЕсли;
		
	КонецЦикла;

	//РедактированиеСубконто(Элемент, СписокСубконто);
	
КонецПроцедуры

// процедура обработки очистки разворота по субконто
// 
// Параметры:
//  ТабличноеПоле - Табличное поле
//
Процедура ОбработкаОчисткиРазворотПоСубконтоТабПоля(ТабличноеПоле) Экспорт

	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);
	
КонецПроцедуры

//процедура очищает данные разворота по субконто текущей строки настроек
Процедура ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(РедактируемаяСтрока)
	
	РедактируемаяСтрока.РазворотПоСубконто.Очистить();
	
	Если РедактируемаяСтрока.РазворотПоСубконто.Колонки.Количество() = 0 Тогда
		
		ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(100));

		РедактируемаяСтрока.РазворотПоСубконто.Колонки.Добавить("Имя",           ОписаниеТиповСтрока);
		РедактируемаяСтрока.РазворотПоСубконто.Колонки.Добавить("Представление", ОписаниеТиповСтрока);
		
	КонецЕсли;

	РедактируемаяСтрока.ПредставлениеРазворотПоСубконто = "";
	
КонецПроцедуры


// Процедура обрабатывает выбор показателей, группировок или фильтров из отдельного окна.
Процедура ОбработкаВыборРазворотаПоСубконто(ВыбранноеЗначение, ТабличноеПоле, СтандартнаяОбработка) Экспорт

	СтандартнаяОбработка = Ложь;
	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);

	Для Каждого Строка Из ВыбранноеЗначение Цикл 

		Если Строка.Пометка Тогда
			
			ДобавитьСубконтоВТаблицуВыбранных(ТабличноеПоле.ТекущиеДанные, Строка.Значение, Строка.Представление);
							
		КонецЕсли;

	КонецЦикла;

	ТабличноеПоле.ТекущиеДанные.ПредставлениеРазворотПоСубконто  = Сред(ТабличноеПоле.ТекущиеДанные.ПредставлениеРазворотПоСубконто, 3);

КонецПроцедуры

//процедура добавляет новое значение субконто в список выбранных
Процедура ДобавитьСубконтоВТаблицуВыбранных(ТаблицаВыбораСубконто, Знач ИмяСубконто, Знач ПредставлениеСубконто)
	
	НоваяСтрокаПоСубконто = ТаблицаВыбораСубконто.РазворотПоСубконто.Добавить();
			
	НоваяСтрокаПоСубконто.Имя = ИмяСубконто;
	НоваяСтрокаПоСубконто.Представление = ПредставлениеСубконто;
			
	ТаблицаВыбораСубконто.ПредставлениеРазворотПоСубконто = ТаблицаВыбораСубконто.ПредставлениеРазворотПоСубконто + ", " 
		+ ПредставлениеСубконто;
	
КонецПроцедуры

// Процедура обрабатывает окончание редактирования настроек развернутого сальдо
// 
// Параметры:
//  Элемент      - Элемент
//  НоваяСтрока  - Новая строка
//  ОтменаРедактирования - признак отмены редактирования
//
Процедура ПриОкончанииРедактированияПравилаРазвернутогоСальдо(Элемент, НоваяСтрока, ОтменаРедактирования) Экспорт

	ТабличноеПоле = Элемент;

	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если НРег(ТабличноеПоле.ТекущаяКолонка.Имя) = НРег("Субсчета") Тогда

		Если ТабличноеПоле.ТекущиеДанные.Субсчета Тогда
			
			ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);
									
		КонецЕсли;
		
	ИначеЕсли НРег(ТабличноеПоле.ТекущаяКолонка.Имя) = НРег("ПредставлениеРазворотПоСубконто") Тогда

		Если ТабличноеПоле.ТекущиеДанные.РазворотПоСубконто.Количество() > 0 Тогда
			
			ТабличноеПоле.ТекущиеДанные.СубСчета = Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура устанавливает связывание данных и визуальных объектов отображения
// настроек бухгалтерских отчетов
//
// Параметры:
//  ПравилаВыводаИтогов - Правила вывода итого
//  ПравилаРазвернутогоСальдо - правила развернутого сальдо
// 
Процедура УстановитьСвязываниеДанныхФормыНастроек(ПравилаВыводаИтогов, ПравилаРазвернутогоСальдо) Экспорт
	
	// Связывание с данными колонок "Счет": тип определяется типом колонки у таблицы
	Если ПравилаВыводаИтогов <> Неопределено Тогда
		ПравилаВыводаИтогов.Колонки.Счет.Данные = "Счет";
		ПравилаВыводаИтогов.Колонки.Счет.ЭлементУправления.КнопкаВыбора = Истина;
		ПравилаВыводаИтогов.Колонки.Счет.ЭлементУправления.КнопкаОчистки = Ложь;
		ПравилаВыводаИтогов.Колонки.ПредставлениеРазворотПоСубконто.ЭлементУправления.КнопкаОчистки = Истина;
	КонецЕсли;
	
	Если ПравилаРазвернутогоСальдо <> Неопределено Тогда
		ПравилаРазвернутогоСальдо.Колонки.Счет.Данные = "Счет";
		ПравилаРазвернутогоСальдо.Колонки.Счет.ЭлементУправления.КнопкаВыбора = Истина;
		ПравилаРазвернутогоСальдо.Колонки.Счет.ЭлементУправления.КнопкаОчистки = Ложь;
		ПравилаРазвернутогоСальдо.Колонки.ПредставлениеРазворотПоСубконто.ЭлементУправления.КнопкаОчистки = Истина;
	КонецЕсли;
		
КонецПроцедуры


// Процедура - обработчик при изменении счета в таблицах детализации или развернутого сальдо
// 
// Параметры:
//  ТабличноеПоле - Табличное поле
//  ТабПолеРазвернутогоСальдо - Табличное поле развернутого сальдо
//
Процедура ОбработчикПриИзмененииСчета(ТабличноеПоле, Знач ТабПолеРазвернутогоСальдо) Экспорт

	РедактируемаяСтрока = ТабличноеПоле.ТекущиеДанные; 
	
	Если РедактируемаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(РедактируемаяСтрока);
	
	// Признак того, что счет найден способ развернуть счет
	НайденСпособРазворота = Ложь;

	Счет = РедактируемаяСтрока.Счет;
	Если ЗначениеЗаполнено(Счет) Тогда
		
		ВыборкаПоСчету = ПланыСчетов[Счет.Метаданные().Имя].Выбрать(Счет);
		Если ВыборкаПоСчету.Следующий() Тогда
			
			РедактируемаяСтрока.Субсчета = Истина;
            НайденСпособРазворота = Истина;
			
		КонецЕсли;

		// Развернутое сальдо только по субсчетам
		Если ТабПолеРазвернутогоСальдо 
			И НайденСпособРазворота Тогда
			
			Возврат;
			
		КонецЕсли;
		
		Если Счет.ВидыСубконто.Количество() > 0 Тогда

			// Развернутое сальдо - отключим субсчета
			Если ТабПолеРазвернутогоСальдо Тогда
				РедактируемаяСтрока.Субсчета = Ложь;
			КонецЕсли;

			Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл

				ДобавитьСубконтоВТаблицуВыбранных(РедактируемаяСтрока, "Субконто" + Строка(ВидСубконто.НомерСтроки), Строка(ВидСубконто.ВидСубконто));
				
			КонецЦикла;

			РедактируемаяСтрока.ПредставлениеРазворотПоСубконто  = Сред(РедактируемаяСтрока.ПредставлениеРазворотПоСубконто, 3);

			НайденСпособРазворота = Истина;

		КонецЕсли;

		// Если у счета нет ни субсчетов, ни субконто, не дадим его выбрать.
		Если НЕ НайденСпособРазворота Тогда
			
			Если ТабПолеРазвернутогоСальдо Тогда
				ВидНастройки = "развернутого сальдо ";
			Иначе
				ВидНастройки = "итогов по субсчетам и субконто ";
			КонецЕсли;
			
			Сообщить("Счет """ + Счет.Код + """ не имеет ни субсчетов, ни субконто." + Символы.ПС + "Настройка " + ВидНастройки + "не имеет смысла!");
					
			РедактируемаяСтрока.Счет = Неопределено;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры


// Процедура формирует и выводит текст в информационной надписи о величине долга контрагента.
//
// Параметры:
//  ДоговорКонтрагента    - ссылка на справочник, определяет договор контрагента; 
//  Сделка                   - ссылка на документ или Неопределено, определяет сделку; 
//  ЭлементФормыНадписьДолга - элемент формы, содержащий надпись долга;
//  СсылкаДокумент           - ссылка на документ, из которого вызывается процедура.
//  МожноНеРассчитывать      - если можно не рассчитывать долг, а в дополнительных правах "Рассчитывать долг 
//                 при открытии форм" = ложь,
//                             то величина долга рассчитываться не будет
//
Процедура СформироватьНадписьДолга(Контрагент, ВалютаВзаиморасчетов, Организация, НадписьДолга, ЦветНадписи, ГиперссылкаНадписи, Дата) Экспорт

	СуммаДолга = уатИнтерфейсВзаимодействияСERPСервер.ТекущийДолг(Контрагент, Организация, ВалютаВзаиморасчетов, Дата);
	
	НадписьДолга = ПолучитьТекстДолга(СуммаДолга, ВалютаВзаиморасчетов);
	
	Если СуммаДолга = 0 Тогда // Долг контрагента, покрасим текст в особый цвет
		ЦветНадписи = ЦветаСтиля.ЦветФонаВыделенияПоля;
		ГиперссылкаНадписи = Ложь;
	Иначе
		ЦветНадписи = WebЦвета.Красный;
		ГиперссылкаНадписи = Истина;
	КонецЕсли; 
		
КонецПроцедуры // СформироватьНадписьДолга()

// Формирует текст о долге контрагента для вывода его в форме документа
//
// Параметры: 
//  ДоговорКонтрагента - ссылка на элемент справочника, определяет договор контрагента
//  Долг                  - число, сумма долга.
//
// Возвращаемое значение:
//  Строка, сформированный текст про долг контрагента.
//
Функция ПолучитьТекстДолга(Знач Долг, ВалютаВзаиморасчетов) Экспорт
	
	Если Долг = Неопределено Тогда
		ТекстПодписи = "Долг не рассчитан";

	ИначеЕсли Долг = 0 Тогда
		ТекстПодписи = "Нет долга";

	Иначе
		Если Долг > 0 Тогда
			ТекстПодписи = "Долг контрагента";
		Иначе
			ТекстПодписи = "Долг компании";
			Долг = (-1) * Долг;
		КонецЕсли;

		ТекстПодписи = ТекстПодписи + " " +
			уатОбщегоНазначенияТиповые.уатФорматСумм(Долг, ВалютаВзаиморасчетов);

	КонецЕсли;

	Возврат ТекстПодписи;

КонецФункции // ПолучитьТекстДолга()


// <Описание функции>
//
// Параметры
//  Периодичность (Перечисления.Периодичность): периодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
//
// Возвращаемое значение:
//   ДатаНачалаПериода   – ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаНачалаПериода()

// <Описание функции>
//
// Параметры
//  Периодичность (Перечисления.Периодичность): периодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
//
// Возвращаемое значение:
//   ДатаКонцаПериода   – ближайшая дата начала периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаКонцаПериода()

// Возвращает число дней в переданном периоде
//
// Параметры
//  Периодичность – Перечисление.Периодичность элемент перечисления, 
//		для которого вычисляется количество дней
//
// Возвращаемое значение:
//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
//
Функция ЧислоДнейВПериоде(Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		ЧислоДнейВПериоде=1;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		ЧислоДнейВПериоде=7;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		ЧислоДнейВПериоде=30;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		ЧислоДнейВПериоде=90;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		ЧислоДнейВПериоде=365;
	Иначе
		ЧислоДнейВПериоде=0;
	КонецЕсли;
	
	Возврат ЧислоДнейВПериоде;	
	
КонецФункции // ЧислоДнейВПериоде()

// <Описание процедуры>
//
//  Периодичность (Перечисления.Периодичность): периодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
// 	Смещение (число): определяет направление и количество периодов, в котором сдвигается дата
//	Возвращаемое значение: дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Смещение=0 Тогда
		НоваяДатаПериода=ДатаПериода;	
	ИначеЕсли Периодичность=Перечисления.Периодичность.День Тогда
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода=НачалоНедели(ДатаПериода+Смещение*7*24*3600);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*3);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*12);
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ = ""гггг """"г.""""""";
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ = ""ММММ гггг """"г.""""""";
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ = ""дд.ММ.гггг """"г.""""""";
	Иначе
		ФорматДаты = "";
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ = """""" по """" дд.ММ.гггг """"г.""""""");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()
