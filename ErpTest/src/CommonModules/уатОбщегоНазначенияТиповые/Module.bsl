
//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ОФОРМЛЕНИЯ ФОРМЫ

// Формирует и устанавливает текст заголовка формы документа
//
// Параметры:
//  СтрокаВидаОперации - строка вида операции документа, 
//  ДокументОбъект     - объект документа, 
//  ФормаДокумента     - форма документа.
//
Процедура уатУстановитьЗаголовокФормыДокумента(СтрокаВидаОперации = "", ДокументОбъект, ФормаДокумента) Экспорт
	
	ФормаДокумента.АвтоЗаголовок = Ложь; // заголовок будем писать сами
	
	Если ПустаяСтрока(СтрокаВидаОперации) Тогда
		Заголовок = ДокументОбъект.Метаданные().Синоним + ": ";
	Иначе
		Заголовок = ДокументОбъект.Метаданные().Синоним + ": " + СтрокаВидаОперации + ". ";
	КонецЕсли;
	
	Если ДокументОбъект.ЭтоНовый() Тогда  
		Заголовок = Заголовок + "Новый";
	Иначе
		Если ДокументОбъект.Проведен Тогда
			Заголовок = Заголовок + "Проведен";
		ИначеЕсли ДокументОбъект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
			Заголовок = Заголовок + "Не проведен";
		Иначе
			Заголовок = Заголовок + "Записан";
		КонецЕсли;
	КонецЕсли;
	
	ФормаДокумента.Заголовок = Заголовок;
	
КонецПроцедуры // УстановитьЗаголовокФормыДокумента()

//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПЕЧАТИ

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция уатСформироватьСуммуПрописью(Сумма, Валюта) Экспорт
	
	Если Валюта.ПараметрыПрописи = "" Тогда
		Возврат уатФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописи);
	КонецЕсли;
	
КонецФункции //уатСформироватьСуммуПрописью()

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция уатСформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт
	
	Возврат НазваниеДокумента + " № " + уатПолучитьНомерНаПечать(ДокументОбъект)
	+ " от " + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'");
	
КонецФункции // СформироватьЗаголовокДокумента()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция уатПолучитьНомерНаПечать(Документ) Экспорт
	
	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;
	
	Номер = СокрЛП(Документ.Номер);
	
	Префикс = "";
	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда
		
		Если ЗначениеЗаполнено(Документ.Организация) Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда
		
		Префикс     = СокрЛП(Документ.Организация.Префикс);
		
	Иначе
		
		МетаданныеДокумента = Документ.Метаданные();
		
		Если уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
			
			Если ЗначениеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// удаление префикса из номера документа
	Если Найти(Номер, Префикс)=1 Тогда 
		Номер = Сред(Номер, СтрДлина(Префикс)+1);
	КонецЕсли;
	
	// так же, может остаться "минус" впереди
	Если Лев(Номер, 1) = "-" Тогда
		Номер = Сред(Номер, 2);
	КонецЕсли;
	
	// удаление ведущих нулей
	Пока Лев(Номер, 1)="0" Цикл
		Номер=Сред(Номер, 2);
	КонецЦикла;
	
	Возврат Номер;
	
КонецФункции // уатПолучитьНомерНаПечать()


//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция уатЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // уатЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Позволяет определить есть ли такой регистр сведения
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеСправочника - объект описания метаданных справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция уатЕстьДокумент(НаименованиеДокумента) Экспорт
	
	Если Метаданные.НайтиПоПолномуИмени("Документ."+СокрЛП(НаименованиеДокумента)) = Неопределено Тогда
		Результат = Ложь;
	Иначе	
		Результат = Истина;
	КонецЕсли;;	
	
	Возврат Результат;
	
КонецФункции

// Позволяет определить есть ли такой регистр сведения
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеСправочника - объект описания метаданных справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция уатЕстьКонстанта(НаименованиеКонстанты) Экспорт
	
	Если Метаданные.НайтиПоПолномуИмени("Константа."+СокрЛП(НаименованиеКонстанты)) = Неопределено Тогда
		Результат = Ложь;
	Иначе	
		Результат = Истина;
	КонецЕсли;;	
	
	Возврат Результат;
	
КонецФункции

// Позволяет определить есть ли среди реквизитов шапки справочника
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  СправочникОбъект - объект / ссылка на справочник / имя справочника в метаданных
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция уатЕстьРеквизитСправочника(ИмяРеквизита, Справочник) Экспорт
	
	Попытка
		Если ТипЗнч(Справочник) = Тип("Строка") Тогда
			МетаданныеСправочника = Метаданные.Справочники[Справочник];
		Иначе
			МетаданныеСправочника = Справочник.Метаданные();
		КонецЕсли;
		
		Если МетаданныеСправочника.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли; 
	Исключение
		Возврат Ложь;
	КонецПопытки;	
	
КонецФункции // ЕстьРеквизитСправочника()

// Позволяет определить есть ли среди реквизитов шапки справочника
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеСправочника - объект описания метаданных справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция уатЕстьИзмерениеРегистра(ИмяРеквизита, Регистр) Экспорт
	
	Попытка
		Если Регистр.Метаданные().Измерения.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли; 
	Исключение
		Возврат Ложь;
	КонецПопытки;	
	
КонецФункции // 

// Функция возвращает строковое представление отбора
// Параметры:
//   Отбор  	  - объект типа Отбор (напр.СправочникСписок.Отбор)
// Возвращаемое значение:
//   Строка       - Строковое представление отбора
//
Функция уатПолучитьПредставлениеОтбора(Отборы) Экспорт
	Если ТипЗнч(Отборы) = Тип("ОтборКомпоновкиДанных") Тогда
		Возврат уатПолучитьПредставлениеОтбораКомпоновщика(Отборы);
	КонецЕсли;
	
	Результат = "";
	Для Каждого Отбор из Отборы Цикл
		Если Отбор.Использование Тогда
			
			Если Отбор.ТипЗначения = Новый ОписаниеТипов("Дата") и уатОбщегоНазначения.уатЗначениеНеЗаполнено(Отбор.Значение) Тогда
				Продолжить;
			КонецЕсли;
			
			Результат = Результат + " ";
			Результат = Результат + СтрЗаменить(Отбор.Представление, "_", " ")  + " ";
			
			Если Отбор.ВидСравнения = ВидСравнения.Равно Тогда
				Результат = Результат + "= " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Больше Тогда
				Результат = Результат + "> " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Меньше Тогда
				Результат = Результат + "< " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Интервал Тогда
				Результат = Результат + НСтр("ru=' > '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
				Результат = Результат + НСтр("ru=' И < '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
				Результат = Результат + НСтр("ru=' >= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
				Результат = Результат + НСтр("ru=' И <= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
				Результат = Результат + НСтр("ru=' >= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
				Результат = Результат + НСтр("ru=' И < '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
				Результат = Результат + НСтр("ru=' > '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
				Результат = Результат + НСтр("ru=' И <= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ВСписке
				Или Отбор.ВидСравнения = ВидСравнения.ВСпискеПоИерархии
				Или Отбор.ВидСравнения = ВидСравнения.НеВСписке
				Или Отбор.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
				Результат = Результат + Нрег(Отбор.ВидСравнения) + " (" + СокрЛП(Отбор.Значение) + ")";
			Иначе
				Результат = Результат + Нрег(Отбор.ВидСравнения) + " " + СокрЛП(Отбор.Значение);
			КонецЕсли;
			Результат = Результат + ";";
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция уатПолучитьПредставлениеОтбораКомпоновщика(ОтборКомпоновки)
	Результат = "";
	Для Каждого Отбор из ОтборКомпоновки.Элементы Цикл
		Если НЕ Отбор.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(Отбор) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			РезГруппа = уатПолучитьПредставлениеОтбораКомпоновщика(Отбор);
			
			Если Отбор.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ Тогда
				Результат = Результат + "И";
			ИначеЕсли Отбор.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли Тогда
				Результат = Результат + "ИЛИ";
			Иначе
				Результат = Результат + "НЕ";
			КонецЕсли;
			
			Результат = Результат + " {" + РезГруппа + "}; ";
			
			Продолжить;
		КонецЕсли;
		
		//Результат = Результат + " ";
		
		ТекИмя = Отбор.Представление;
		Если НЕ ЗначениеЗаполнено(ТекИмя) Тогда
			ТекИмя = Отбор.ЛевоеЗначение;
		КонецЕсли;
		
		Результат = Результат + СтрЗаменить(ТекИмя, "_", " ")  + " ";
		
		Если Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
			Результат = Результат + "= " + СокрЛП(Отбор.ПравоеЗначение);
		ИначеЕсли Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
			Результат = Результат + "<> " + СокрЛП(Отбор.ПравоеЗначение);
		ИначеЕсли Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
			Результат = Результат + "> " + СокрЛП(Отбор.ПравоеЗначение);
		ИначеЕсли Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
			Результат = Результат + "< " + СокрЛП(Отбор.ПравоеЗначение);
		ИначеЕсли Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке
			Или Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии
			Или Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке
			Или Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии Тогда
			Результат = Результат + Нрег(Отбор.ВидСравнения) + " (" + СокрЛП(Отбор.ПравоеЗначение) + ")";
		Иначе
			Результат = Результат + Нрег(Отбор.ВидСравнения) + " " + СокрЛП(Отбор.ПравоеЗначение);
		КонецЕсли;
		
		Результат = Результат + "; ";
	КонецЦикла;
	
	Если Прав(Результат, 2) = "; " Тогда
		Результат = Лев(Результат, СтрДлина(Результат)-2);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция уатФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;
	
КонецФункции

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция уатПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ОбщегоНазначения.ПолучитьСписокЭлементовПеречисления()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

// Функция "расщепляет" строку на подстроки заданной длины.
//
//	Параметры: 
//		ИсходнаяСтрока - строка, которую необходимо разложить на подстроки. 
//						 Параметр передается по значению.
//		ДлинаПодстроки - число, длина требуемой подстроки.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция уатРазбитьСтрокуНаПодстроки(ИсходнаяСтрока, ДлинаПодстроки) Экспорт
	МассивСтрок = Новый Массив;
	СтрокаРазделителей = Новый Массив;
	СтрокаРазделителей.Добавить(" ");
	СтрокаРазделителей.Добавить(",");
	СтрокаРазделителей.Добавить(".");
	СтрокаРазделителей.Добавить("-");
	СтрокаРазделителей.Добавить(":");
	СтрокаРазделителей.Добавить(";");
	
	Сч1 = ДлинаПодстроки;
	Пока СтрДлина(ИсходнаяСтрока) > ДлинаПодстроки Цикл
		НайденРазделитель = 0;
		ЧастьСтроки = Лев(ИсходнаяСтрока, ДлинаПодстроки);
		Пока Сч1 <> 1 Цикл
			Для Каждого Разделитель Из СтрокаРазделителей Цикл
				Если Найти(Сред(ЧастьСтроки, Сч1, 1), Разделитель) > 0 Тогда
					НайденРазделитель = 1;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НайденРазделитель Тогда
				Прервать
			КонецЕсли;
			Сч1 = Сч1 - 1;
		КонецЦикла;
		Если НайденРазделитель Тогда
			МассивСтрок.Добавить(Лев(ИсходнаяСтрока, Сч1));
			ИсходнаяСтрока = СокрЛП(Сред(ИсходнаяСтрока, Сч1 + 1, СтрДлина(ИсходнаяСтрока)));
		Иначе
			МассивСтрок.Добавить(Лев(ИсходнаяСтрока, ДлинаПодстроки-1) + "-");
			ИсходнаяСтрока = СокрЛП(Сред(ИсходнаяСтрока, ДлинаПодстроки, СтрДлина(ИсходнаяСтрока)));
		КонецЕсли;
	КонецЦикла;
	
	МассивСтрок.Добавить(ИсходнаяСтрока);
	
	Возврат МассивСтрок;
КонецФункции

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов, 
//               перечисленные через запятую, в формате требований к свойствам структуры.
//               Например, "Код, Наименование, Родитель".
//               Если Структура, то в качестве ключа передается псевдоним поля для
//               возвращаемой структуры с результатом, а в качестве значения (опционально) 
//               - фактическое имя поля в таблице. 
//               Если значение не определено, то имя поля берется из ключа.
// 
// Возвращаемое значение:
//  Структура    - содержит список свойств, как список имен в строке
//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
//                 из информационной базы.
// 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

	//добавлен код для возврата значений для пустой ссылки
	Попытка
		Если Ссылка.Пустая() Тогда
			Возврат Ссылка;
		КонецЕсли;
	Исключение
		Возврат Новый Структура(ИменаРеквизитов);
	КонецПопытки;
		
	Если ТипЗнч(ИменаРеквизитов) = Тип("Структура") Тогда
		СтруктураРеквизитов = ИменаРеквизитов;
	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип("Строка") Тогда
		СтруктураРеквизитов = Новый Структура(ИменаРеквизитов);;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра ИменаИлиСтруктураРеквизитов: %1'"), 
			Строка(ТипЗнч(ИменаРеквизитов)));
	КонецЕсли;

	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;

	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|" + ТекстПолей + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
		|");
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();

	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);

	Возврат Результат;
КонецФункции

// Функция ПолучитьЗначениеРеквизита возвращает значение
// реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

//=================================================================================
//ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ НУМЕРАЦИЕЙ И ПРЕФИКСАЦИЕЙ ОБЪЕКТОВ

// Процедура устанавливает значение префикса для документа
//
// Параметры:
//	ДокументОбъект - ссылка на документ, для которого требуется сформировать префикс
//	Префикс - параметры ссылка,для возврата значения префикса
//
Процедура уатДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		Префикс = "0";

	Иначе

		Префикс = ДокументОбъект.Организация.Префикс;

	КонецЕсли;
	
Конецпроцедуры

// Процедура выполняет добавление префикса узла
//
// Параметры:
//  Префикс      - добавляемый префикс
Процедура уатДобавитьПрефиксУзла(Префикс) Экспорт
	Если Метаданные.Константы.Найти("ПрефиксУзлаРаспределеннойИнформационнойБазы") <> Неопределено Тогда
		ПрефиксУзла = Константы.ПрефиксУзлаРаспределеннойИнформационнойБазы.Получить();
		Если НЕ ПустаяСтрока(ПрефиксУзла) Тогда
			Префикс = ПрефиксУзла + Префикс;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

//Процедура очистки введенного кода/номера объекта
// Параметры
//  ЭтотОбъект  - объект.
//	КодНомер - имя обрабатываемого реквизита (Код или Номер)
//  ПодменюДействия - меню "Действия" командной панели формы. В этот меню должен присутствовать 
//                 пункт "Редактировать код/номер"
//  ПолеВводаНомера - поле вводе, связанное с кодом/номером объекта
//
Процедура уатСброситьУстановленныйКодНомерОбъекта(ЭтотОбъект, КодНомер, ПодменюДействия = Неопределено, ПолеВводаНомера) Экспорт
	
	ОбъектМетаданные = ЭтотОбъект.Метаданные();
	
	Если ОбъектМетаданные.Реквизиты.Найти("Организация") = Неопределено Тогда
		ЭтотОбъект[КодНомер] = "";
	Иначе
		ДлинаПрефикса = СтрДлина(ЭтотОбъект.Организация.Префикс);
		Если ДлинаПрефикса = 0 ИЛИ Лев(ПолеВводаНомера.Значение, ДлинаПрефикса) <> ЭтотОбъект.Организация.Префикс Тогда
			ЭтотОбъект[КодНомер] = "";
		КонецЕсли;
	КонецЕсли;
	
	//Если ЭтотОбъект[КодНомер] = "" Тогда
	//	ОбновитьПодсказкуКодНомерОбъекта(ОбъектМетаданные, ПодменюДействия, ПолеВводаНомера);
	//КонецЕсли;
		
КонецПроцедуры // СброситьУстановленныйКодНомерОбъекта()


//=================================================================================
// РЕГИСТРАЦИЯ ДАННЫХ НЕЗАРЕГИСТРИРОВАННЫХ КОНТРАГЕНТОВ, БЕЗ ДОБАВЛЕНИЯ В СПРАВОЧНИК

// Процедура выполняет запись данных незарегистрированного контрагентов 
//
Процедура уатЗаписатьДанныеНезарегистрированногоКонтрагента(Ссылка, ДанныеНезарегистрированногоКонтрагента, Отказ) Экспорт
	
	ДанныеНезарегистрированногоКонтрагента.ОбъектРегистратор = Ссылка;
	
	Попытка
		ДанныеНезарегистрированногоКонтрагента.Записать(Истина);
	Исключение
		СообщитьОбОшибке(ОписаниеОшибки(),, "Не удалось записать данные контрагента.");
		Отказ = Истина;
	КонецПопытки;
	
КонецПроцедуры

// Процедура выполняет чтение данных незарегистрированного документа 
//
Процедура уатПрочитатьДанныеНезарегистрированногоКонтрагента(Ссылка, ДанныеНезарегистрированногоКонтрагента) Экспорт
	
	Если НЕ уатОбщегоНазначения.уатЗначениеНеЗаполнено(Ссылка) Тогда
		ДанныеНезарегистрированногоКонтрагента.ОбъектРегистратор = Ссылка;
		ДанныеНезарегистрированногоКонтрагента.Прочитать();
	КонецЕсли; 
	
КонецПроцедуры


//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура уатВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт
	
	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // уатВыполнитьДвижениеПоРегистру()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//	Параметры:
//		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//		- ВидДвижения - вид движения накопления (приход/расход)
//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//		- ДатаДвижения - дата на которую будут формироваться записи
//
Процедура уатЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
		
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			уатВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			уатВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // уатЗаписатьТаблицыДокументаВРегистр()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех 
// таблиц (например значением шапки документа)
//	Параметры:
//  СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ИмяПоля - имя колонки в таблицах документа, в которую будет установлено новое значение
//  УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//  СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//                 имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура уатУстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
		
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
			СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // уатУстановитьЗначениеВТаблицыДокумента()

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
// Параметры:
//  Движение - движение документа (т.е. регистр)
//  СтруктТаблицДокумента - структура содержащая таблицы документа. ключ - имя таблицы, 
//                    значение - таблица значений с данными документа.
//
// Возврат:
//  Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция уатЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
		
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;
	
КонецФункции // уатЗагрузитьТаблицыДокументаВСтруктуру()

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	//Сформируем массив совпадающих колонок.
	МассивСовпадающихКолонок = Новый Массив();
	Для каждого Колонка Из ТаблицаПриемник.Колонки Цикл
		
		Если ТаблицаИсточник.Колонки.Найти(Колонка.Имя) <> Неопределено Тогда
			
			МассивСовпадающихКолонок.Добавить(Колонка.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		
		// Заполним значения в совпадающих колонках.
		Для каждого ЭлементМассива Из МассивСовпадающихКолонок Цикл
			
			СтрокаТаблицыПриемника[ЭлементМассива] = СтрокаТаблицыИсточника[ЭлементМассива];
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()


//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ТАБЛИЧНОЙ ЧАСТИ ТОРГОВЫХ ДОКУМЕНТОВ

// Устанавливает запрет на изменение видимости заданных колонок в заданной коллекции колонок 
// табличного поля
//
// Параметры:
//  Колонки          - коллекция колонок табличного поля,
//  СтруктураКолонок - структура, содержащая имена колонок, видимость которых отключить нельзя
//
Процедура уатУстановитьИзменятьВидимостьКолонокТабЧасти(Колонки, СтруктураКолонок) Экспорт
	
	// устанавливаем стандартные запреты на изменение видимости колонок
	Для каждого КолонкаТаблицы из Колонки Цикл
		КолонкаТаблицы.ИзменятьВидимость = НЕ СтруктураКолонок.Свойство(КолонкаТаблицы.Имя);
	КонецЦикла;
	
КонецПроцедуры // уатУстановитьИзменятьВидимостьКолонокТабЧасти()

// Изменяет видимость колонки табличного поля (например, табличной части документа).
// Если изменение видимости колонки запрещено, то предварительно разрешает изменять видимость колонки.
//
// Параметры:
//  Колонка   - колонка табличного поля, 
//  Видимость - булево, устанавливаемый флаг видимости колонки.
//
Процедура уатУстановитьВидимостьКолонкиТабЧасти(Колонка, Видимость) Экспорт
	
	Если Колонка.ИзменятьВидимость Тогда
		Колонка.Видимость = Видимость;
	Иначе // надо вначале разрешить менять видимость
		Колонка.ИзменятьВидимость = Истина;
		Колонка.Видимость = Видимость;
		Колонка.ИзменятьВидимость = Ложь;
	КонецЕсли; 
	
КонецПроцедуры // уатУстановитьВидимостьКолонкиТабЧасти()

// Процедура заполняет Содержание из полного наименования номенклатуры в строке табличной части
//
// Параметры
//  СтрокаТабличнойЧасти - Строка табличной части
//
Процедура уатЗаполнитьСодержаниеТабЧасти(СтрокаТабличнойЧасти, Документобъект) Экспорт
	
	ИмяТабличнойЧасти = уатОбщегоНазначенияТиповыеСервер.ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти);
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитТабЧастиДокумента("Содержание", МетаданныеДокумента, ИмяТабличнойЧасти) Тогда
		СтрокаТабличнойЧасти.Содержание = СтрокаТабличнойЧасти.Номенклатура.НаименованиеПолное;
	КонецЕсли;
	
КонецПроцедуры // уатЗаполнитьСодержаниеТабЧасти()

// Процедура очищает значение нужного реквизита в переданной ТЧ.
//
// Параметры:
//  ТабЧаст      - табличная часть,
//  ИмяРеквизита - строка, имя реквизита.
//
Процедура уатОчиститьРеквизитТЧ(ТабЧасть, ИмяРеквизита) Экспорт
	
	Для Каждого Строка Из ТабЧасть Цикл
		Если Не уатОбщегоНазначения.уатЗначениеНеЗаполнено(Строка[ИмяРеквизита]) Тогда
			Строка[ИмяРеквизита] = Неопределено;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры //уатОчиститьРеквизитТЧ()

// Процедура выполняет стандартные действия при изменении суммы 
// в строке табличной части документа.
//
// Параметры:
//  СтрокаТабличнойЧасти - строка табличной части документа,
//  ДокументОбъект       - объект редактируемого документа
//
Процедура уатПриИзмененииСуммыТабЧасти(СтрокаТабличнойЧасти, ДокументОбъект, ТекПользователь, РасчетАвтоматическихСкидок = Ложь) Экспорт
	
	ИмяТабличнойЧасти = уатОбщегоНазначенияТиповыеСервер.ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти);
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если уатОбщегоНазначения.уатЗначениеНеЗаполнено(СтрокаТабличнойЧасти.Количество) Тогда
		СтрокаТабличнойЧасти.Цена = 0;
	Иначе
		СтрокаТабличнойЧасти.Цена = СтрокаТабличнойЧасти.Сумма / СтрокаТабличнойЧасти.Количество;
	КонецЕсли; 
	
КонецПроцедуры // уатПриИзмененииСуммыТабЧасти()   

// Процедура заполняет ставку НДС в строке табличной части документа
//
// Параметры:
//  СтрокаТабличнойЧасти     - строка табличной части документа,
//  ДокументОбъект           - объект редактируемого документа.
//
Процедура уатЗаполнитьСтавкуНДСТабЧасти(СтрокаТабличнойЧасти, ДокументОбъект) Экспорт
	
	ИмяТабличнойЧасти = уатОбщегоНазначенияТиповыеСервер.ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти);
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	//Заполнить СтавкаНДС
	Если ЕстьРеквизитТабЧастиДокумента("СтавкаНДС", МетаданныеДокумента, ИмяТабличнойЧасти) Тогда
		СтрокаТабличнойЧасти.СтавкаНДС = СтрокаТабличнойЧасти.Номенклатура.СтавкаНДС;
	КонецЕсли;
	
КонецПроцедуры // уатЗаполнитьСтавкуНДСТабЧасти()

// Рассчитывает сумму в строке табличной части документа
//
// Параметры:
//  СтрокаТабличнойЧасти - строка табличной части документа,
//  ДокументОбъект       - объект редактируемого документа,
//  СпособРасчета        - "Со всеми скидками", сумма минус скидки;
//                         "Без учета ручной скидки", сумма минус автоматические скидки;
//                         "Без учета скидок", сумма (Цена * Количество);
//
Процедура уатРассчитатьСуммуТабЧасти(СтрокаТабличнойЧасти, ДокументОбъект, СпособРасчета = Неопределено) Экспорт
	
	ИмяТабличнойЧасти = уатОбщегоНазначенияТиповыеСервер.ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти);
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	СтрокаТабличнойЧасти.Сумма = СтрокаТабличнойЧасти.Цена * СтрокаТабличнойЧасти.Количество;
	
КонецПроцедуры // уатРассчитатьСуммуТабЧасти()

// Расчет, исходя из постоянной суммы
//
// Параметры:
//  СтрокаТабличнойЧасти - строка табличной части документа,
//  ДокументОбъект       - объект редактируемого документа.
//
Процедура уатРассчитатьСуммуНДСТабЧасти(СтрокаТабличнойЧасти, ДокументОбъект) Экспорт
	
	// Если в документе нет флагов учета НДС, то в конфигурации считается, что суммы включают НДС.
	УчитыватьНДС = Истина;
	СуммаВключаетНДС = Истина;
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	Если уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента ) Тогда
		УчитыватьНДС = ДокументОбъект.УчитыватьНДС;
	КонецЕсли;
	
	Если уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента ) Тогда
		СуммаВключаетНДС = ДокументОбъект.СуммаВключаетНДС;
	КонецЕсли;
	
	СтрокаТабличнойЧасти.СуммаНДС = уатРассчитатьСуммуНДС(СтрокаТабличнойЧасти.Сумма,
	УчитыватьНДС, СуммаВключаетНДС,
	уатПолучитьСтавкуНДС(СтрокаТабличнойЧасти.СтавкаНДС));
	
КонецПроцедуры // уатРассчитатьСуммуНДСТабЧасти()

// Расчет, исходя из постоянной суммы
//
// Параметры:
//  СтрокаТабличнойЧасти - строка табличной части документа,
//  ДокументОбъект       - объект редактируемого документа.
//
Процедура уатРассчитатьСуммуНДСПередачиТабЧасти(СтрокаТабличнойЧасти, ДокументОбъект) Экспорт
	
	ИмяТабличнойЧасти = уатОбщегоНазначенияТиповыеСервер.ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти);
	
	СтрокаТабличнойЧасти.СуммаНДСПередачи = уатРассчитатьСуммуНДС(СтрокаТабличнойЧасти.СуммаПередачи,
	ДокументОбъект.УчитыватьНДС,
	ДокументОбъект.СуммаВключаетНДС,
	уатПолучитьСтавкуНДС(СтрокаТабличнойЧасти.СтавкаНДС));
	
КонецПроцедуры // уатРассчитатьСуммуНДСТабЧасти()

// Функция выполняет поиск первой, удовлетворяющей условию поиска, строки табличной части.
//
// Параметры:
//  ТабличнаяЧасть - табличная часть документа, в которой осуществляется поиск,
//  СтруктураОтбора - структура - задает условие поиска.
//
// Возвращаемое значение: 
//  Строка табличной части - найденная строка табличной части,
//  Неопределено           - строка табличной части не найдена.
//
Функция уатНайтиСтрокуТабЧасти(ТабличнаяЧасть, СтруктураОтбора) Экспорт
	
	СтрокаТабличнойЧасти = Неопределено;
	МассивНайденныхСтрок = ТабличнаяЧасть.НайтиСтроки(СтруктураОтбора);
	Если МассивНайденныхСтрок.Количество() > 0 Тогда
		
		// Нашли. Вернем первую найденную строку.
		СтрокаТабличнойЧасти = МассивНайденныхСтрок[0];
	КонецЕсли;
	
	Возврат СтрокаТабличнойЧасти;
	
КонецФункции // уатНайтиСтрокуТабЧасти()

// Функция возвращает признак можно ли пользователю изменять цены в расходных накладных или нет.
//
// Параметры:
//  нет.
//
// Возвращаемое значение:
//  Истина - если можно менять цены, иначе Ложь.
//
Функция уатРазрешитьРедактированиеЦенВДокументах() Экспорт
	Возврат Истина;
КонецФункции // уатРазрешитьРедактированиеЦенВДокументах()

// Проверяет, что в табличной части нет товаров.
//
// Параметры:
//  ДокументОбъект    - объект проводимого документа, 
//  ИмяТабличнойЧасти - табличная часть документа,
//  ТаблицаЗначений   - таблица значений, содержащая данные табличной части и признак услуги
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура уатПроверитьЧтоНетТоваров(ДокументОбъект, ИмяТабличнойЧасти, ТаблицаЗначений = Неопределено, 
                                                    Отказ, Заголовок) Экспорт
	
	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	
	Если ТаблицаЗначений <> Неопределено И ТаблицаЗначений.Количество() > 0 Тогда
		ТаблицаПроверки_ = ТаблицаЗначений;
	Иначе
		ТаблицаПроверки_ = ДокументОбъект[ИмяТабличнойЧасти]
	КонецЕсли;
	
	Для каждого СтрокаТаблицы Из ТаблицаПроверки_ Цикл
		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
			""" табличной части """ + ПредставлениеТабличнойЧасти + """: ";
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.Номенклатура)
			И НЕ уатОбщегоНазначения.ВидНоменклатурыУслуга(СтрокаТаблицы.Номенклатура) Тогда
			
			СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке
				+ "содержится номенклатура, не являющаяся услугой. " + "Здесь могут быть только услуги!", Отказ, Заголовок);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры // ПроверитьЧтоНетТоваров

// Проверяет, что в табличной части нет услуг.
//
// Параметры:
//  ДокументОбъект    - объект проводимого документа, 
//  ИмяТабличнойЧасти - табличная часть документа,
//  ТаблицаЗначений   - таблица значений, содержащая данные табличной части и признак услуги
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЧтоНетУслуг(ДокументОбъект, ИмяТабличнойЧасти, ТаблицаЗначений = Неопределено, 
                                                    Отказ, Заголовок) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	
	Если (НЕ ТаблицаЗначений = Неопределено) И (ТаблицаЗначений.Количество() > 0) Тогда
		// Цикл по строкам таблицы значений.
		Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
			
			СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
			                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";
			
			Если Не уатОбщегоНазначения.уатЗначениеНеЗаполнено(СтрокаТаблицы.Номенклатура)
			   И  СтрокаТаблицы.Услуга Тогда
				
					уатОбщегоНазначенияТиповые.СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + "содержится услуга. " +
					                   "Услуг здесь быть не должно!", Отказ, Заголовок);
				
			КонецЕсли;
			
		КонецЦикла;
	Иначе
		// Цикл по строкам табличной части документа.
		Для Каждого СтрокаТаблицы Из ДокументОбъект[ИмяТабличнойЧасти] Цикл
			
			СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
			                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";
			
			Если НЕ уатОбщегоНазначения.уатЗначениеНеЗаполнено(СтрокаТаблицы.Номенклатура)
				И уатОбщегоНазначения.ВидНоменклатурыУслуга(СтрокаТаблицы.Номенклатура) Тогда 
				
				уатОбщегоНазначенияТиповые.СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + "содержится услуга. " +
					"Услуг здесь быть не должно!", Отказ, Заголовок);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры //ПроверитьЧтоНетУслуг()

// Функция производит поиск подчиненного документа
//
// Параметры:
//  ДокументСсылка - Документ для которого производиться поиск подчиненных документов
//  ВидДокумента - Строка - вид искомого подчиненного документа 
//  Реквизит     - имя реквизита документа значение которого проверяется
//  Значение     - значение проверяемого реквизита
//
// Возвращаемое значение:
//  НайденныйДокумент - документ ссылка.
Функция уатНайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента, Реквизит = Неопределено, Значение = Неопределено) Экспорт

	НайденныйДокумент = Неопределено;
	Если ЗначениеЗаполнено(ДокументСсылка) И ЗначениеЗаполнено(ВидДокумента) Тогда

		Запрос = Новый Запрос;

		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);

		Запрос.Текст = "
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Документ.Ссылка
		|ИЗ
		|	Документ."+ВидДокумента+" КАК Документ
		|ГДЕ
		|	Документ.ДокументОснование = &ДокументСсылка";
		
		Если Реквизит<>Неопределено И ЗначениеЗаполнено(Реквизит) Тогда
			Запрос.Текст = Запрос.Текст + " И Документ."+Реквизит+" = &"+Реквизит;
			Запрос.УстановитьПараметр(Реквизит,Значение);
		КонецЕсли;

		Выборка = Запрос.Выполнить().Выбрать();

		Если Выборка.Следующий() Тогда
			НайденныйДокумент = Выборка.Ссылка;
		КонецЕсли;

	КонецЕсли;

	Возврат НайденныйДокумент;
	
КонецФункции // НайтиПодчиненныйДокумент()

// Пересчитывает сумму НДС
//
// Параметры:
//  Нет.
//
Процедура ПересчитатьСуммуНДС(СтрокаПлатеж) Экспорт
	
	ЗначениеСтавкиНДС = уатПолучитьСтавкуНДС(СтрокаПлатеж.СтавкаНДС);
	СтрокаПлатеж.СуммаНДС = СтрокаПлатеж.СуммаПлатежа * ЗначениеСтавкиНДС / (100+ЗначениеСтавкиНДС);
	
КонецПроцедуры // ПересчитатьСуммуНДС()

//=================================================================================
// ПРОЦЕДУРЫ РАБОТЫ С ПЕРИОДАМИ

// Выравнивает дату по началу периода.
//
// Параметры:
//  ДатаПланирования  - выравниваемая дата
//  Периодичность     - тип интервала для выравнивания
//  НазваниеДаты 	  - наименование вида даты для вывода сообщения
//  ВыводитьСообщение - признак необходимости вывода сообщения о выравнивании
//
Процедура уатВыровнятьДатуПоНачалуПериода(ДатаПланирования, Периодичность, НазваниеДаты = "Дата начала периода ", ВыводитьСообщение=Ложь) Экспорт
	
	ДатаИзменена = Ложь;
	ДатаНачПериода = ДатаПланирования;
	уатВыровнятьПериод(ДатаНачПериода,, Периодичность);
	
	Если ДатаПланирования <> ДатаНачПериода Тогда
		
		ДатаПланирования = ДатаНачПериода;
		ДатаИзменена = Истина;
		
	КонецЕсли;
	
	Если ВыводитьСообщение и ДатаИзменена Тогда
		
		СообщитьОбОшибке(НазваниеДаты + "изменена в соответствии с установленной периодичностью.");
		
	КонецЕсли;
	
КонецПроцедуры // ВыровнятьДатуПоНачалуПериода()

// Процедура выравнивает начальную и конечную даты по границам указанной периодичности
// 		ДатаНачПериода - дата, которую нужно выровнять по началу указанной периодичностью
// 		ДатаКонПериода - дата, которую нужно выровнять по окончанию указанной периодичностью
// 		Периодичность - периодичность, определяющая границы выравнивания
// 
Процедура уатВыровнятьПериод(ДатаНачПериода = Неопределено, ДатаКонПериода = Неопределено, Периодичность = Неопределено) Экспорт
	
	Если ТипЗнч(Периодичность) <> Тип("ПеречислениеСсылка.Периодичность") ИЛИ Периодичность = Перечисления.Периодичность.ПустаяСсылка() Тогда
		
		ТекущаяПериодичность = Перечисления.Периодичность.День;
		
	Иначе
		
		ТекущаяПериодичность = Периодичность;
		
	КонецЕсли;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	НАЧАЛОПЕРИОДА(&ДатаНач, " + Строка(ТекущаяПериодичность) + ") КАК ДатаНач,
	|	КОНЕЦПЕРИОДА(&ДатаКон, " + Строка(ТекущаяПериодичность) + ") КАК ДатаКон");
	
	Запрос.УстановитьПараметр("ДатаНач", ?(ТипЗнч(ДатаНачПериода) <> Тип("Дата"), Дата('00010101'), ДатаНачПериода));
	Запрос.УстановитьПараметр("ДатаКон", ?(ТипЗнч(ДатаКонПериода) <> Тип("Дата"), Дата('00010101'), ДатаКонПериода));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	ДатаНачПериода = Выборка.ДатаНач;
	ДатаКонПериода = Выборка.ДатаКон;
	
КонецПроцедуры // ВыровнятьПериод()

// Выравнивает дату по окончанию периода.
//
// Параметры:
//  ДатаПланирования  - выравниваемая дата
//  Периодичность     - тип интервала для выравнивания
//  НазваниеДаты 	  - наименование вида даты для вывода сообщения
//  ВыводитьСообщение - признак необходимости вывода сообщения о выравнивании
//
Процедура уатВыровнятьДатуПоКонцуПериода(ДатаПланирования, Периодичность, НазваниеДаты = "Дата окончания периода ", ВыводитьСообщение = Ложь) Экспорт
	
	ДатаИзменена = Ложь;
	ДатаКонПериода = ДатаПланирования;
	уатВыровнятьПериод(, ДатаКонПериода, Периодичность);
	
	Если ДатаПланирования <> ДатаКонПериода Тогда
		
		ДатаПланирования = ДатаКонПериода;
		ДатаИзменена = Истина;
		
	КонецЕсли;
	
	Если ВыводитьСообщение и ДатаИзменена Тогда
		
		СообщитьОбОшибке(НазваниеДаты + "изменена в соответствии с установленной периодичностью.");
		
	КонецЕсли;
	
КонецПроцедуры // уатВыровнятьДатуПоКонцуПериода()

//=================================================================================
// !!!Удалить

// Рассчитываем сумму документа со всеми налогами
//
// Параметры: 
//  ДокументОбъект    - объект документа, сумму которого надо рассчитать
//  ИмяТабличнойЧасти - строка, имя табличной части, сумму которой надо рассчитать.
//                      Если она не заполнена, считаем по всем табличным частям, в которых есть "Сумма"
//  НеУчитыватьТару   - булево, если Истина и ИмяТабличнойЧасти неопределено, то в расчете сумм тару не учитываем
//
// Возвращаемое значение:
//  Сумма документа со всеми налогами.
//
Функция уатПолучитьСуммуДокументаСНДС(ДокументОбъект, ИмяТабличнойЧасти = Неопределено, НеУчитыватьТару = Истина) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	СуммаДокумента = 0;
	Если ИмяТабличнойЧасти <> Неопределено Тогда
		СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("Сумма");
		Если уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
			И уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
			И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ИмяТабличнойЧасти)
			И ДокументОбъект.УчитыватьНДС
			И Не ДокументОбъект.СуммаВключаетНДС Тогда
			СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("СуммаНДС");
		КонецЕсли; 
	Иначе
		Для каждого ТЧОбъекта Из ДокументОбъект.Метаданные().ТабличныеЧасти Цикл
			Если НеУчитыватьТару и ТЧОбъекта.Имя = "ВозвратнаяТара" Тогда
				Продолжить;
			КонецЕсли;
			Если ЕстьРеквизитТабЧастиДокумента("Сумма", МетаданныеДокумента, ТЧОбъекта.Имя) Тогда
				СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("Сумма");
				Если уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
					И уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
					И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ТЧОбъекта.Имя)
					И ДокументОбъект.УчитыватьНДС
					И Не ДокументОбъект.СуммаВключаетНДС Тогда
					СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("СуммаНДС");
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СуммаДокумента;
	
КонецФункции // ПолучитьСуммуДокументаСНДС()

// Рассчитываем сумму НДС документа
//
// Параметры: 
//  ДокументОбъект    - объект документа, сумму которого надо рассчитать
//  ИмяТабличнойЧасти - строка, имя табличной части, сумму которой надо рассчитать.
//                      Если она не заполнена, считаем по всем табличным частям, в которых есть "Сумма"
//
// Возвращаемое значение:
//  НДС документа
//
Функция ПолучитьНДСДокумента(ДокументОбъект, ИмяТабличнойЧасти = Неопределено) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	СуммаНДС = 0;
	Если ИмяТабличнойЧасти <> Неопределено Тогда
		СуммаНДС = СуммаНДС + ДокументОбъект[ИмяТабличнойЧасти].Итог("СуммаНДС");
	Иначе
		Для каждого ТЧОбъекта Из ДокументОбъект.Метаданные().ТабличныеЧасти Цикл
			Если ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ТЧОбъекта.Имя) Тогда
				СуммаНДС = СуммаНДС + ДокументОбъект[ТЧОбъекта.Имя].Итог("СуммаНДС");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СуммаНДС;
	
КонецФункции // ПолучитьСуммуДокументаСНДС()

// Функция возвращает курс ставку НДС
//
// Параметры:
//  Валюта - СправочникСсылка.Валюты, валюта, по которой необходимо получить курс
//  ДатаКурса - Дата, календарная дата, на которую необходимо получить курс валюты
//
// Возвращаемое значение:
//	Курс переданной валюты на переданную дату, 1 в случае отсутствия значения.
//
Функция уатПолучитьСтавкуНДС(СтавкаНДС) Экспорт
	
	Если СтавкаНДС = Перечисления.СтавкиНДС.НДС10 ИЛИ СтавкаНДС = Перечисления.СтавкиНДС.НДС10_110 Тогда
		Возврат 10;
	ИначеЕсли СтавкаНДС = Перечисления.СтавкиНДС.НДС18 ИЛИ СтавкаНДС = Перечисления.СтавкиНДС.НДС18_118 Тогда
		Возврат 18;
	ИначеЕсли Метаданные.Перечисления.СтавкиНДС.ЗначенияПеречисления.Найти("НДС20") <> Неопределено
		И СтавкаНДС = Перечисления.СтавкиНДС.НДС20
		ИЛИ Метаданные.Перечисления.СтавкиНДС.ЗначенияПеречисления.Найти("НДС20_120") <> Неопределено
		И СтавкаНДС = Перечисления.СтавкиНДС.НДС20_120 Тогда
		Возврат 20;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции // ПолучитьСтавкуНДС()

// Рассчитывает сумму НДС исходя из суммы и флагов налогообложения
//
// Параметры: 
//  Сумма            - число, сумма от которой надо рассчитывать налоги, 
//  УчитыватьНДС     - булево, признак учета НДС в сумме, 
//  СуммаВключаетНДС - булево, признак включения НДС в сумму ("внутри" или "сверху"),
//  СтавкаНДС        - число , процентная ставка НДС,
//
// Возвращаемое значение:
//  Число, полученная сумма НДС
//
Функция уатРассчитатьСуммуНДС(Сумма, УчитыватьНДС, СуммаВключаетНДС, СтавкаНДС) Экспорт
	
	Если (УчитыватьНДС) И (СуммаВключаетНДС) Тогда
		СуммаБезНДС = 100 * Сумма / (100 + СтавкаНДС);
		СуммаНДС = Сумма - СуммаБезНДС;
	Иначе
		СуммаБезНДС = Сумма;
	КонецЕсли;
	
	Если УчитыватьНДС Тогда 
		Если НЕ СуммаВключаетНДС Тогда
			СуммаНДС = СуммаБезНДС * СтавкаНДС / 100;
		КонецЕсли;
	Иначе
		СуммаНДС = 0;
	КонецЕсли;
	
	Возврат СуммаНДС;
	
КонецФункции // РассчитатьСуммуНДС()

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулях форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета,
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются,
//  ПараметрОбъектКопирования      - ссылка на объект копирования,
//  ПараметрОснование              - ссылка на объект-основание.
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ВалютаРегламентированногоУчета = Неопределено, ТипОперации = "", ПараметрОбъектКопирования = Неопределено, ПараметрОснование = Неопределено) Экспорт

	Перем ТипЦен;

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	ДатаДокумента = ?(НЕ ЗначениеЗаполнено(ДокументОбъект.Дата), ТекущаяДата(), ДокументОбъект.Дата);
	
	Если уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента) И (НЕ ЗначениеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	Попытка
		Если уатЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента) И (НЕ ЗначениеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)) Тогда
			ДокументОбъект.ПодразделениеОрганизации = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновноеПодразделениеОрганизации");
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Если уатЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокумента)
	   И НЕ ЗначениеЗаполнено(ДокументОбъект.СтруктурнаяЕдиница) 
	   И уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	   И уатЕстьРеквизитСправочника("ОсновнойБанковскийСчет", ДокументОбъект.Организация) Тогда
		ДокументОбъект.СтруктурнаяЕдиница = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
	  ДокументОбъект.Ответственный = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнойОтветственный");
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ВидОперации)) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.Склад)) Тогда
		ДокументОбъект.Склад = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента)
	   И НЕ ЗначениеЗаполнено(ДокументОбъект.СкладОрдер) Тогда
		ДокументОбъект.СкладОрдер = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("СтавкаНДС", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.СтавкаНДС)) Тогда
		ДокументОбъект.СтавкаНДС = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнаяСтавкаНДС");
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента)
	   И НЕ ЗначениеЗаполнено(ДокументОбъект.БанковскийСчет)
	   И уатЕстьРеквизитСправочника("ОсновнойБанковскийСчет", ДокументОбъект.Организация) Тогда
		ДокументОбъект.БанковскийСчет = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		Если уатЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
		И НЕ ЗначениеЗаполнено(ДокументОбъект.СчетОрганизации)
		И уатЕстьРеквизитСправочника("ОсновнойБанковскийСчет", ДокументОбъект.Организация) Тогда
		ДокументОбъект.СчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
		ДокументОбъект.ВалютаДокумента = ВалютаРегламентированногоУчета;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.КурсДокумента)) Тогда
	    СтруктураКурсаДокумента      = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
		ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

		Если уатЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.КурсВзаиморасчетов)) Тогда
		СтруктураКурсаДокумента = ПолучитьКурсВалюты(ВалютаРегламентированногоУчета, ДатаДокумента);
		ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаДокумента.Курс;

		Если уатЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;
	
	флСуммаВключаетНДС = Истина;
	
	Если уатОбщегоНазначенияТиповые.уатЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента) Тогда

		// Если тип цен оказался не заполненным, то берем его из установок пользователя
		Если НЕ ЗначениеЗаполнено(ДокументОбъект.ТипЦен) И ТипОперации = "Продажа" Тогда
			ДокументОбъект.ТипЦен = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(ТекПользователь, "ОсновнойТипЦенПродажи");
		КонецЕсли;
		Если ЗначениеЗаполнено(ДокументОбъект.ТипЦен) Тогда

			// Если ТипЦен - элемент справочника ТипыЦенНоменклатуры и цены выбранного типа расчетные, 
			// то флаги включения налогов надо брать из базовой цены
			Если ТипЗнч(ДокументОбъект.ТипЦен) = Тип("СправочникСсылка.ТипыЦенНоменклатуры") 
			   И уатЕстьРеквизитДокумента("БазовыйТипЦен",ДокументОбъект.ТипЦен.Метаданные()) 
			   И уатЕстьРеквизитДокумента("Рассчитывается",ДокументОбъект.ТипЦен.Метаданные()) И ДокументОбъект.ТипЦен.Рассчитывается Тогда
				флСуммаВключаетНДС = ДокументОбъект.ТипЦен.БазовыйТипЦен.ЦенаВключаетНДС;
			Иначе
				флСуммаВключаетНДС = ДокументОбъект.ТипЦен.ЦенаВключаетНДС;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если уатОбщегоНазначенияТиповые.уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
	   И (Не ДокументОбъект.УчитыватьНДС) Тогда

		ДокументОбъект.УчитыватьНДС = Истина;

		Если уатОбщегоНазначенияТиповые.уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента) Тогда
			ДокументОбъект.СуммаВключаетНДС = флСуммаВключаетНДС;
		КонецЕсли;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("ЗанимаемыхСтавок", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ЗанимаемыхСтавок)) Тогда
		ДокументОбъект.ЗанимаемыхСтавок = 1;
	КонецЕсли;

	Если уатЕстьРеквизитДокумента("ДатаС", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ДатаС)) Тогда
		ДокументОбъект.ДатаС = ДокументОбъект.Дата;
	КонецЕсли;
	
	# Если Клиент Тогда

	Если уатЕстьРеквизитДокумента("ПериодРегистрации", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ПериодРегистрации)) Тогда
		ДокументОбъект.ПериодРегистрации = НачалоМесяца(РабочаяДата);
	КонецЕсли;

	#КонецЕсли


КонецПроцедуры // ЗаполнитьШапкуДокумента()

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция уатФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт
	
	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
	?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
	?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции // ФорматСумм()

// Проверяет. можно ли использовать переданный договор в соответствии с переданными параметрами.
//
// Параметры
//  Договор                                 – ссылка на договор, который нужно проверить,
//  Контрагент                              - ссылка на контрагента, которому должен принадлежать договор,
//  Организация                             - ссылка на организацию, от имени которой должен быть выписан договор,
//  СтруктураПараметровДляПолученияДоговора - структура, содержащая параметры для определения договора:
//                                            список допустимых видов договоров и
//                                            список допустимых способов ведения взаиморасчетов.
//
// Возвращаемое значение:
//   Логическое, Истина - можно использовать, ложь - нельзя.
//
Функция уатМожноИспользоватьДоговорДляДокумента(Договор, Контрагент, Организация, СтруктураПараметровДляПолученияДоговора) Экспорт

	Перем СписокДопустимыхВидовДоговоров, ВалютаВзаиморасчетовДоговора, ВидСравненияВалютыВзаиморасчетов;

	Если Не ЗначениеЗаполнено(Договор) Тогда
		Возврат Ложь; // Если не передали параметры, то считаем, что нельзя использовать.
	КонецЕсли;

	Если СтруктураПараметровДляПолученияДоговора <> Неопределено Тогда
		СтруктураПараметровДляПолученияДоговора.Свойство("СписокДопустимыхВидовДоговоров"     , СписокДопустимыхВидовДоговоров);
		СтруктураПараметровДляПолученияДоговора.Свойство("ВалютаВзаиморасчетовДоговора"       , ВалютаВзаиморасчетовДоговора);
		СтруктураПараметровДляПолученияДоговора.Свойство("ВидСравненияВалютыВзаиморасчетов"   , ВидСравненияВалютыВзаиморасчетов);
	КонецЕсли;

	// Организация должна совпадать.
	Если ЗначениеЗаполнено(Организация)
	   И Организация <> Договор.Организация Тогда
		Возврат Ложь;
	КонецЕсли;

	// Контрагент должен совпадать, если в документе не выбран контрагент, то любой договор не подходит.
	Если Контрагент <> Договор.Контрагент Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверка по виду договора.
	Если СписокДопустимыхВидовДоговоров <> Неопределено Тогда
		Если уатОбщегоНазначенияТиповые.уатЕстьРеквизитСправочника("ТипДоговора", "ДоговорыКонтрагентов") Тогда
			Если СписокДопустимыхВидовДоговоров.НайтиПоЗначению(Договор.ТипДоговора) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе
			Если СписокДопустимыхВидовДоговоров.НайтиПоЗначению(Договор.ВидДоговора) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// Проверка по валюте взаиморасчетов.
	Если ВалютаВзаиморасчетовДоговора <> Неопределено
	   И ВидСравненияВалютыВзаиморасчетов <> Неопределено Тогда
		Если ВидСравненияВалютыВзаиморасчетов = "=" Тогда
			Если Договор.ВалютаВзаиморасчетов <> ВалютаВзаиморасчетовДоговора Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе // ВидСравненияВалютыВзаиморасчетов может принимать только два значения: "=" и "<>".
			Если Договор.ВалютаВзаиморасчетов = ВалютаВзаиморасчетовДоговора Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат Истина;

КонецФункции // МожноИспользоватьДоговорДляДокумента()

// Определяет кратность документа, которая равен либо кратности документа (если в документе она существует),
// либо кратности взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - кратность валюты в документе.
//
Функция уатКратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт
	
	// Если валюта документа совпадает с валютой регл. учета, то кратность 1.
	Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		// Если есть реквизит КратностьДокумента - его и вернем
		Если уатЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			Возврат ДокументОбъект.КратностьДокумента;
		КонецЕсли;
		
		// Если нет КратностьДокумента и валюта документа не совпадает с валютой регл. учета, 
		// то такой документ может быть выписан только в валюте взаиморасчетов,
		// если есть реквизит КратностьВзаиморасчетов - его и вернем.
		Если уатЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
			Возврат ДокументОбъект.КратностьВзаиморасчетов;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат 1;
	
КонецФункции // КратностьДокумента()

// Определяет курс документа, который равен либо курсу документа (если в документе он существует),
// либо курсу взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект                 - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - курс документа.
//
Функция уатКурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт
	
	// Если валюта документа совпадает с валютой регл. учета, то курс 1.
	Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		// Если есть реквизит КурсДокумента - его и вернем
		Если уатЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			Возврат ДокументОбъект.КурсДокумента;
		КонецЕсли;
		
		// Если нет КурсДокумента и валюта документа не совпадает с валютой регл. учета, 
		// то такой документ может быть выписан только в валюте взаиморасчетов,
		// если есть реквизит КурсВзаиморасчетов - его и вернем.
		Если уатЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
			Возврат ДокументОбъект.КурсВзаиморасчетов;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат 1;
	
КонецФункции // КурсДокумента()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция уатПредставлениеДокументаПриПроведении(Документ) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	ВидОперацииСтр = "";
	Если уатЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;
	
	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;
	
КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизитов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура уатПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	//ПроверитьПринадлежностьКВидамУчета();
	
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
		
		Значение = ДокументОбъект[КлючЗначение.Ключ];
		Если НЕ ЗначениеЗаполнено(Значение) Тогда
			
			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизитов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура уатПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
	Отказ, Заголовок) Экспорт
	
	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	ТабличнаяЧасть = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
		
		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
		""" табличной части """ + ПредставлениеТабличнойЧасти + """: ";
		
		// Цикл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
			
			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда
				
				Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
				Иначе
					СтрокаСообщения = КлючЗначение.Значение;
				КонецЕсли;
				СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()


//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ ПЕРСОНАЛОМ

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры:
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция уатФамилияИнициалыФизЛица(Объект = Неопределено, Фамилия = " ", Имя = " ", Отчество = " ") Экспорт
	
	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") ИЛИ ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") Тогда 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.Сотрудники") ИЛИ ТипОбъекта = Тип("СправочникОбъект.Сотрудники") Тогда 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.Организации") ИЛИ ТипОбъекта = Тип("СправочникОбъект.Организации") Тогда 
		Возврат Объект.Наименование;
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
		Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
		"")
	КонецЕсли;
	
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
	Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
	"");
	
КонецФункции

// Увеличивает номер в переданной строке на 1
//
// Параметры
//  ПоследнийНомер - строка - представляет собой номер (документа, табельный и т.п.)
//
// Возвращаемое значение:
//  строка  - следующий по порядку номер
//
Функция уатПолучитьСледующийНомер(ПоследнийНомер) Экспорт 

	ДлинаНомера = СтрДлина(ПоследнийНомер);
	Если ДлинаНомера = 0 Тогда
		Возврат "1"
	КонецЕсли;
	СчетчикСимв = ДлинаНомера;
	Пока СчетчикСимв > 0 Цикл
		Если Не ПустаяСтрока(Сред(ПоследнийНомер, СчетчикСимв, 1)) и СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Сред(ПоследнийНомер, СчетчикСимв, 1)) Тогда
			СчетчикСимв = СчетчикСимв - 1;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если СчетчикСимв = ДлинаНомера Тогда
		НомерЧисловой = 1
	Иначе
		НомерЧисловой = Число(Сред(ПоследнийНомер, СчетчикСимв + 1));
	КонецЕсли;
	Если НомерЧисловой < Pow(10, ДлинаНомера - СчетчикСимв) - 1 Тогда
		СледующийНомер = НомерЧисловой + 1;
	Иначе
		СледующийНомер = НомерЧисловой;
	КонецЕсли;
	НовыйНомер = Лев(ПоследнийНомер,  СчетчикСимв) + Формат(СледующийНомер,"ЧЦ=" + (ДлинаНомера - СчетчикСимв) + "; ЧВН=; ЧГ=0");
	Возврат НовыйНомер
	
КонецФункции // ПолучитьСледующийНомер()

//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт
	
	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");
	
	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.
		
		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();
		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;
		
	КонецЕсли;
	
	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");
	
	Если СтрокаПоля = Неопределено Тогда // нужно добавить
		
		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();
		
		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;
		
	КонецЕсли;
	
	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");
	
	Если СтрокаПоля = Неопределено Тогда // нужно добавить
		
		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();
		
		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;
		
	КонецЕсли;
	
КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// Формирует запрос на дополнительные параметры, нужные при проведении документа.
//
// Параметры: 
//  ДокументОбъект                 - объект проводимого документа, 
//  ДеревоПолейЗапросаПоШапке      - дерево значений, содержащего имена полей, 
//                                   которые нужно заполнить в запросе по шапке документа.
//  СтруктураШапкиДокумента        - структура, содержащая значения реквизитов, относящихся к шапке документа,
//                                   необходимых для его проведения.
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Дополненная по результату запроса структура СтруктураШапкиДокумента.
//
Функция СформироватьЗапросПоДеревуПолей(ДокументОбъект, ДеревоПолейЗапросаПоШапке, СтруктураШапкиДокумента, ВалютаРегламентированногоУчета)  Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ";

	СтрокиЗапроса           = "";
	ТаблицыЗапроса          = "";
	НуженКурсВалютыУпрУчета = Ложь;
	ЕстьУчетнаяПолитика     = Ложь;
	
	// Реквизиты договора взаиморасчетов.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДоговорыКонтрагентов", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДоговорКонтрагента." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты договора взаиморасчетов регл.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДоговорыКонтрагентовРегл", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДоговорКонтрагентаРегл." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты сделки.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Сделка", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Сделка." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Склад", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Склад." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладОтправитель", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладОтправитель." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументПеремещения", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументПеремещения." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументПередачи", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументПередачи." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада-получателя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладПолучатель", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладПолучатель." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты склада-ордера
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладОрдер", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладОрдер." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Заказ", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Заказ." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ВнутреннийЗаказ", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ВнутреннийЗаказ." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты заказа покупателя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ЗаказыПокупателей", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ЗаказПокупателя." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Реквизиты заказа поставщику
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ЗаказыПоставщикам", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ЗаказПоставщику." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;

	// Реквизиты номенклатуры
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Номенклатура", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Номенклатура." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;

	// Реквизиты документа основания
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументОснование", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументОснование." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

		КонецЦикла;

	КонецЕсли;
	
	// Константы.
	ТаблицыЗапроса = ТаблицыЗапроса + ", Константы";

	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Константы", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда

		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл

			Если СтрокаПоля.Поле = "КурсВалютыУправленческогоУчета" Тогда

				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "КурсыВалютСрезПоследних.Курс КАК КурсВалютыУправленческогоУчета";
			
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "КурсыВалютСрезПоследних.Кратность КАК КратностьВалютыУправленческогоУчета";
			
				НуженКурсВалютыУпрУчета = Истина;

			Иначе

				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "Константы." + СокрЛП(СтрокаПоля.Поле) +
				?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));

			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("УчетнаяПолитика", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		ЕстьУчетнаяПолитика = Истина;
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС + 
			Символы.Таб + "УчетнаяПолитикаСрезПоследних." + СокрЛП(СтрокаПоля.Поле) +
				?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
		КонецЦикла;
			
	КонецЕсли;

	// Надо добавить константу ВалютаРегламентированногоУчета
	СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС + 
	Символы.Таб + "Константы.ВалютаРегламентированногоУчета КАК ВалютаРегламентированногоУчета";

	СтрокаЗапросаКурсВалютыУпрУчета = Символы.ПС + "
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КурсыВалют.СрезПоследних(&ДатаДокумента,) КАК КурсыВалютСрезПоследних
	|	ПО Константы."
	+ ?(Метаданные.Константы.Найти("ВалютаУправленческогоУчета") <> Неопределено, "ВалютаУправленческогоУчета", "ВалютаРегламентированногоУчета")
	+ " = КурсыВалютСрезПоследних.Валюта";

	Если Метаданные.РегистрыСведений.Найти("УчетнаяПолитикаОрганизаций") <> Неопределено Тогда
		СтрокаРегистраУчетнойПолитики = Символы.ПС + "
		|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УчетнаяПолитикаОрганизаций.СрезПоследних(&ДатаДокумента, Организация = &Организация) КАК УчетнаяПолитикаСрезПоследних
		|	ПО Истина";
	Иначе
		СтрокаРегистраУчетнойПолитики = Символы.ПС + "
		|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УчетнаяПолитика.СрезПоследних(&ДатаДокумента,) КАК УчетнаяПолитикаСрезПоследних
		|	ПО Истина";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ " + Сред(СтрокиЗапроса, 2) + "
	                | ИЗ 
	                |      Документ." + ДокументОбъект.Метаданные().Имя + " КАК Док "+ ТаблицыЗапроса +
	                ?(НуженКурсВалютыУпрУчета, СтрокаЗапросаКурсВалютыУпрУчета,"") + Символы.ПС + 
	                ?(ЕстьУчетнаяПолитика, СтрокаРегистраУчетнойПолитики,"") + Символы.ПС + "
	                |     ГДЕ Док.Ссылка = &ДокументСсылка";

	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	Запрос.УстановитьПараметр("ДатаДокумента", ДокументОбъект.Дата);

	ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();

	Для каждого Колонка из ТаблицаЗапроса.Колонки Цикл
		Если ТаблицаЗапроса.Количество() = 0 Тогда
			СтруктураШапкиДокумента.Вставить(Колонка.Имя, Неопределено);
		Иначе
			СтруктураШапкиДокумента.Вставить(Колонка.Имя, ТаблицаЗапроса[0][Колонка.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		Если уатЕстьРеквизитДокумента("ВалютаДокумента", ДокументОбъект.Метаданные()) Тогда
			СтруктураШапкиДокумента.Вставить("КурсДокумента", 		уатКурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
			СтруктураШапкиДокумента.Вставить("КратностьДокумента", 	уатКратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьЗапросПоДеревуПолей()

//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитывать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитывать;
// 	ПоКурсуНач     - курс из которого надо пересчитать, может быть указана дата для валюты нач;
// 	ПоКурсуКон     - курс в который надо пересчитать, может быть указана дата для валюты кон;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, Знач ПоКурсуНач, Знач ПоКурсуКон, Знач ПоКратностьНач = 1, Знач ПоКратностьКон = 1) Экспорт
	Если ВалютаНач = ВалютаКон Тогда
		// Считаем, что пересчет не нужен.
		Возврат Сумма;
	КонецЕсли;
	
	//если входные параметры - даты расчета курсов, то по ним курс и кратность считаем уже здесь
	Если ТипЗнч(ПоКурсуНач) = Тип("Дата") И ТипЗнч(ПоКурсуКон) = Тип("Дата") Тогда
		СтруктураНачКурс = ПолучитьКурсВалюты(ВалютаНач, ПоКурсуНач);
		ПоКурсуНач = СтруктураНачКурс.Курс;
		ПоКратностьНач = СтруктураНачКурс.Кратность;
		СтруктураКонКурс = ПолучитьКурсВалюты(ВалютаКон, ПоКурсуКон);
		ПоКурсуКон = СтруктураКонКурс.Курс;
		ПоКратностьКон = СтруктураКонКурс.Кратность;
	КонецЕсли;
	
	Если ПоКурсуНач = ПоКурсуКон И ПоКратностьНач = ПоКратностьКон Тогда
		// ну, тут и считать нечего...
		Возврат Сумма;
	КонецЕсли;
	
	Если ПоКурсуНач = 0 ИЛИ ПоКратностьНач = 0 Тогда
		СообщитьОбОшибке("При пересчете обнаружен нулевой курс или кратность валюты """ + ВалютаНач + """!");
		Возврат 0;
	КонецЕсли;
	Если ПоКурсуКон = 0 ИЛИ ПоКратностьКон = 0 Тогда
		СообщитьОбОшибке("При пересчете обнаружен нулевой курс или кратность валюты """ + ВалютаКон + """!");
		Возврат 0;
	КонецЕсли;
	
	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);	
КонецФункции //ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, Знач ДатаКурса) Экспорт
	
	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
	
КонецФункции // ПолучитьКурсВалюты()


//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ПОДСИСТЕМЫ ВЗАИМОРАСЧЕТОВ

// Проверяет, что организация в документе совпадает с организацией, указанной в договоре взаиморасчетов.
//  при несовпадении устанавливается флаг отказа в проведении.
//
// Параметры:
//  Организация           - ссылка на организацию, выбранную в документе,
//  ДоговорКонтрагента - ссылка на договор, выбранный в документе,
//  ДоговорОрганизация    - ссылка на Организацию, выбранную в договоре,
//  Отказ                 - флаг отказа в проведении.
//  Заголовок             - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, 
	                                                  ДоговорОрганизация, Отказ, Заголовок) Экспорт

	// Если не заполнен договор или организация, то не ругаемся.
	Если Не уатОбщегоНазначения.уатЗначениеНеЗаполнено(Организация) 
	   И Не уатОбщегоНазначения.уатЗначениеНеЗаполнено(ДоговорКонтрагента)
	   И Организация <> ДоговорОрганизация Тогда
		СообщитьОбОшибке("Выбран договор контрагента, не соответствующий организации, указанной в документе!", Отказ, Заголовок);
	КонецЕсли;

КонецПроцедуры // УправлениеВзаиморасчетами.ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов()

// Проверяет наличие установленного курс аи кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт
	
	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);
	
	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда
		
		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов
		
		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();
		
		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которому необходимо
//            получить паспортные данные.
//
// Возвращаемое значение:
//  Строка с данными об удостоверении личности физического лица
//
Функция уатПолучитьПаспортныеДанныеСтрокой(ФизЛицо) Экспорт
	
	#Если Клиент Тогда
		ДатаПолучения = РабочаяДата;
	#Иначе
		ДатаПолучения = ТекущаяДата();
	#КонецЕсли
	
	СтруктураПаспортныхДанных	= РегистрыСведений.ДокументыФизическихЛиц.ПолучитьПоследнее(ДатаПолучения, Новый Структура("ФизЛицо",ФизЛицо));
	
	Если ЗначениеЗаполнено(СтруктураПаспортныхДанных.Представление) Тогда
		Возврат СтруктураПаспортныхДанных.Представление;
	Иначе
		Возврат НСтр("ru = 'Отсутствуют данные об удостоверении личности.'");
	КонецЕсли;
	
КонецФункции // ПолучитьПаспортныеДанныеСтрокой()


//=================================================================================
// РАБОТА С ДИАЛОГАМИ

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  Валюта                         - Валюта, курс которой необходимо отобразить
//  Курс                           - курс, которой необходимо отобразить
//  Кратность                      - кратность, которую необходимо отобразить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  СформироватьСкобки             - признак необходимости скобок
//
// Возвращаемое значение:
//  Строка с данными о курсе и кратности валюты
//
Функция ПолучитьИнформациюКурсаВалютыСтрокой(Валюта, Курс, Кратность, ВалютаРегламентированногоУчета, СформироватьСкобки = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Валюта) Тогда
		Возврат "";
		
	Иначе
		Возврат ?(СформироватьСкобки, "   ( ", "") + Кратность + " "
		+ СокрЛП(Валюта)
		+ " = "
		+ Курс + " " 
		+ СокрЛП(ВалютаРегламентированногоУчета)
		+ ?(СформироватьСкобки, " )", "");
	КонецЕсли;
	
КонецФункции // ПолучитьИнформациюКурсаВалютыСтрокой()


//////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт
	
	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
		
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);
	
КонецФункции // ()

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//  Заголовок - заголовок сообщения
//  Статус - статус сообщения
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если  ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе                             
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()


//////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ ДОКУМЕНТОВ

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
//	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт
	
	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();
	
	// Организация.
	Если уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;
	
	// Подразделение.
	Если уатЕстьРеквизитДокумента("Подразделение", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("Подразделение", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Подразделение = ДокументОснование.Подразделение;
	КонецЕсли;
	
	// Ответственный.
	Если уатЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
		ДокументОбъект.Ответственный = уатОбщегоНазначенияПовтИсп.ПолучитьЗначениеПоУмолчаниюПользователя(
			ПараметрыСеанса.ТекущийПользователь, "ОсновнойОтветственный");
	КонецЕсли;
	
	// Склад.
	Если уатЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("Склад", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Склад = ДокументОснование.Склад;
	КонецЕсли;
	
	// Контрагент.
	Если уатЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("Контрагент", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Контрагент = ДокументОснование.Контрагент;
	КонецЕсли;
	
	// ДоговорКонтрагента.
	Если уатЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокументаОснования) 
		И (НЕ уатЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
		ИЛИ ДокументОбъект.Организация = ДокументОснование.ДоговорКонтрагента.Организация) Тогда
		
		ДокументОбъект.ДоговорКонтрагента = ДокументОснование.ДоговорКонтрагента;
		
		// КурсВзаиморасчетов.
		Если уатЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
			СтруктураКурсаВзаиморасчетов = ОбщегоНазначения.ПолучитьКурсВалюты(
				ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
			ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;
			
			// КратностьВзаиморасчетов.
			Если уатЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	// Банковский счет 
	Если уатЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
		
		// Если в документе-основании есть структурная единица(или касса), то берем ее оттуда
		Если уатЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаОснования) Тогда
			Если ЗначениеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
				И (уатРаботаСМетаданными.ЕстьСправочник("БанковскиеСчета") И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета")
				ИЛИ НЕ уатРаботаСМетаданными.ЕстьСправочник("БанковскиеСчета") И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчетаОрганизаций")) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли уатЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
			Если ЗначениеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Банковский счет организации
	Если уатЕстьРеквизитДокумента("БанковскийСчетОрганизации", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
		
		Если Не ЗначениеЗаполнено(ДокументОбъект.БанковскийСчетОрганизации)
			И ЗначениеЗаполнено(ДокументОбъект.БанковскийСчет)Тогда
			ДокументОбъект.БанковскийСчетОрганизации = ДокументОснование.БанковскийСчет;
		КонецЕсли;
	КонецЕсли;
	
	// ВалютаДокумента.
	Если уатЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокументаОснования) Тогда
		
		// Если есть касса или банковский счет, то валюта должна браться только оттуда
		Если уатЕстьРеквизитДокумента("Касса", МетаданныеДокумента) Тогда
			Если ЗначениеЗаполнено(ДокументОбъект.Касса) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
			КонецЕсли;
		ИначеЕсли уатЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
			Если ЗначениеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
			КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;
		
		// КурсДокумента.
		Если уатЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			СтруктураКурсаДокумента = ОбщегоНазначения.ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;
			
			// КратностьДокумента.
			Если уатЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	// ТипЦен.
	Если уатЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("ТипЦен", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипЦен = ДокументОснование.ТипЦен;
	КонецЕсли;
	
	// Тип скидки.
	Если уатЕстьРеквизитДокумента("ТипСкидкиНаценки", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("ТипСкидкиНаценки", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипСкидкиНаценки = ДокументОснование.ТипСкидкиНаценки;
	КонецЕсли;
	// Тип скидки.
	Если уатЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ДисконтнаяКарта = ДокументОснование.ДисконтнаяКарта;
	КонецЕсли;
	
	// УчитыватьНДС.
	Если уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.УчитыватьНДС = ДокументОснование.УчитыватьНДС;
	КонецЕсли;
	
	// СуммаВключаетНДС.
	Если уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
		И уатЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.СуммаВключаетНДС = ДокументОснование.СуммаВключаетНДС;
	КонецЕсли;
	
	Если уатЕстьРеквизитДокумента("ИспользоватьПлановуюСебестоимость", МетаданныеДокумента) Тогда
		Если уатЕстьРеквизитДокумента("ИспользоватьПлановуюСебестоимость", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ИспользоватьПлановуюСебестоимость = ДокументОснование.ИспользоватьПлановуюСебестоимость;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()


//////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ КОНТАКТНОЙ ИНФОРМАЦИИ

// Получить значение определенного вида контактной информации у объекта.
//
// Параметры
//  Ссылка                  - ЛюбаяСсылка - ссылка на объект-владелец контактной информации (организация, контрагент, партнер и т.д.)
//  ВидКонтактнойИнформации - СправочникСсылка.ВидыКонтактнойИнформации
//
// Возвращаемое значение:
//  Строка - строковое представление значения.
//
Функция ПолучитьКонтактнуюИнформацияОбъекта(Ссылка, ВидКонтактнойИнформации) Экспорт
	
	ТекстЗапроса =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	КонтактнаяИнформация.Представление
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + ".КонтактнаяИнформация КАК КонтактнаяИнформация
		|ГДЕ
		|	КонтактнаяИнформация.Ссылка = &Ссылка
		|	И КонтактнаяИнформация.Вид = &Вид";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.УстановитьПараметр("Вид",    ВидКонтактнойИнформации);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Представление;
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции


//=================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт
	
	ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;
	
	Возврат МассивыСовпадают;
	
КонецФункции // МассивыИдентичны()